<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大山</title>
  
  <subtitle>这是一个热爱技术、热爱烹饪的肥宅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-07T16:00:59.924Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>大山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Coursera机器学习笔记(五) - Logistic Regression</title>
    <link href="http://yoursite.com/2018/09/07/machine_learning_note_05/"/>
    <id>http://yoursite.com/2018/09/07/machine_learning_note_05/</id>
    <published>2018-09-07T15:59:57.178Z</published>
    <updated>2018-09-07T16:00:59.924Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><blockquote><p>课程地址：<a href="https://www.coursera.org/learn/machine-learning/home/week/3" target="_blank" rel="noopener">Logistic Regression</a><br>课程Wiki：<a href="https://share.coursera.org/wiki/index.php/ML:Logistic_Regression" target="_blank" rel="noopener">Logistic Regression</a></p></blockquote><h4 id="模型展示"><a href="#模型展示" class="headerlink" title="模型展示"></a>模型展示</h4><h5 id="从线性回归解到对数几率回归"><a href="#从线性回归解到对数几率回归" class="headerlink" title="从线性回归解到对数几率回归"></a>从线性回归解到对数几率回归</h5><p>前面的课程中提到了一些分类问题:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_68.png" alt="pic01"></p><a id="more"></a><p>对于乳腺癌的那个例子, 数据集如下所示. 如果使用线性回归来处理这个问题, 我们可能得到这样一个假设函数:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_615.png" alt="pic02"><br>然后我们设定一个阈值0.5, 当假设函数的输出大于这个阈值时我们预测$y=1$；当假设函数的输出小于0.5时, 我们预测$y=0$。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_69.png" alt="pic03"><br>即使我们的问题是一个分类问题, 但是对于上面这个特定的例子, 看上去使用线性回归好像还是挺合理的. 但是如果我们再增加一个数据(下图最右), 使用Linear Regression就会得到如图蓝色线所示的$h_\theta(x)$。<br>这个结果显然是不合理的, 它有很多错误的分类。 直观上来看, 要是能得到图中垂直于横轴的(图中蓝色)线那便是极好的。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_70.png" alt="pic04"><br>而且即使所有的训练样例的$y = 0或1$, 使用线性回归得到的$h_\theta(x)$也有可能大于1或者小于0。<br>所以我们需要一个能更好地处理分类问题的模型, 即对数几率回归(Logistic Regression/Logit regression). (有些地方翻译成’逻辑回归’或者’逻辑斯蒂格回归’) 需要注意的是这个模型虽然叫regression, 但是它是一个用来解决分类问题的模型. 在对率回归(对数几率回归的简称)中,$0\le h_\theta(x)\le1$。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_618.png" alt="pic05"></p><h5 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h5><p>在对率回归中, 假设函数为$h_\theta(x)=g(\theta^Tx)$，其中$g(z)=\frac{1}{1+e^{-z}}$，$g(z)$叫做Sigmoid Function或者对率函数(Logistic Function)。<br>对数几率函数是Sigmoid函数的一种, 它将z值转化为一个接近0或1的y值, 并且其输出值在$z=0$附近变化很陡. Sigmoid函数即形似S的函数, 对率函数是Sigmoid函数最重要的代表。<br>$${h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}}$$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_72.png" alt="pic06"><br>我们可以将对率函数的输出理解为当输入为x的时候, y=1的概率. 可以用$h_\theta(x)=P(y=1|x;\theta)$表达. 例如, 在下图中, 我们给定一个x, 它的假设函数的输出为0.7, 我们可以说这个病人的肿瘤为恶性的概率是70%。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_73.png" alt="pic07"></p><h5 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h5><p>如图所示的Sigmoid函数, 我们可以看到, 当$z&gt;0$的时候$g(z)\ge0.5$即预测$y=1$；当$z&lt;0$的时候$g(z)&lt;0.5$即预测$y=0$。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_619.png" alt="pic08"><br>而在对率回归中, 我们的$z=\theta^Tx$，所以我们有：当$\theta^Tx&gt;0$时，预测$y=1$；当$\theta^Tx&lt;0$时，预测$y=0$。如下图所示<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_620.png" alt="pic09"><br>下面举一个例子看一看什么是决策边界. 如下图所示, 左边为数据集. 假设此时我们已经通过训练得到了$\theta=\begin{bmatrix}-3\ 1\ 1\end{bmatrix}$，由上图可知, 当$\theta^Tx&gt;0$时，预测$y=1$，即当$-3+x_1+x_2\ge0$时, 预测$y=1$；也即当$x_1+x_2\ge3$时, 预测$y=1$。我们在坐标中画出$x_1+x_2=3$的图形, 如果数据在这条直线的上方, 我们就预测$y=1$；如果数据在这条直线的下方, 我们就预测$y=0$，我们把$x_1+x_2\ge3$称为决策边界(Decision Boundary)。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_75.png" alt="pic10"><br>下面看一个比较复杂的决策边界的例子。在线性回归的时候谈到过使用高阶多项式特征, 当然这里我们也可以用。我们添加两个特征一个是$x_1^2$，一个是$x_2^2$，假设我们通过训练得到参数$\theta$，如下图所示。当$-1+x_1^2+x_2^2\ge0$的时候, 预测$y=1$，即$x_1^2+x_2^2\ge1$的时候, 预测$y=1$，画出$x_1^2+x_2^2=1$的图形，在圆内$y=0$，在园外$y=1$。这是一个圆形的决策边界。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_621.png" alt="pic11"><br>当我们有更高阶的多项式时, 我们会得到更加复杂的决策边界。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_622.png" alt="pic12"></p><h4 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h4><p>在之前的线性回归中, 我们的代价函数为：<br>$${J(\theta)=\frac{1}{m}\sum_{i=1}^m\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}$$<br>令<br>$$Cost\left(h_\theta(x^{(i)}),y^{(i)}\right)=\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2$$<br>简记为<br>$$Cost\left(h_\theta(x),y\right)=\frac{1}{2}\left(h_\theta(x)-y\right)^2$$<br>在线性回归中, 之所以可以使用梯度下降来找到全局最优解是因为代价函数$J(\theta)$是一个凸函数(convex). 但是对于对率回归来说, 假设函数$h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$是一个较为复杂的非线性函数, 直接带入的话得到的代价函数就不是一个凸函数(non-convex), 如下图左侧部分所示. 这样使用梯度下降只能找到局部最优. 所以现在我们需要构造一个合理的并且是凸函数的代价函数。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_77.png" alt="pic13"><br>在对数几率回归中, 使用如下的$Cost\left(h_\theta(x),y\right)$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_80.png" alt="pic14"><br>当$y=1$时，$Cost\left(h_\theta(x),y\right)$如下图所示，此时, 如果我们$h_\theta(x)=1$，那么$Cost=0$，即当预测结果和真实结果一样时, 我们不对学习算法进行惩罚；但是当结果不一致时, 即$h_\theta(x)→ 0$时, 我们对算法的惩罚趋近于无穷。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_81.png" alt="pic15"><br>同样地, 下图是当$y=0$时的情况<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_82.png" alt="pic16"><br>这样对代价函数处理之后, 我们的代价函数就是一个凸函数, 可以使用梯度下降来站到一个全局最优解。</p><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>因为y的值只有0或1两种情况, 我们现在将$Cost\left(h_\theta(x),y\right)$用一个式子来表达:<br>$${Cost\left(h_\theta(x),y\right)=-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))}$$<br>(可以带入验证)<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_83.png" alt="pic17"><br>于是得到代价函数:<br>$${J(\theta)=-\frac{1}{m}\left[\sum_{i=1}^my^{(i)}log(h_\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\theta(x^{(i)}))\right]}$$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_84.png" alt="pic18"><br>到这里, 后面的步骤就和线性回归很相似了. 直接利用梯度下降即可. 同样地我们需要求偏导, 求完偏导之后我们发现得到的更新规则和之前线性回归的更性规则是一模一样的. 除了假设函数$h_\theta(x)$一样. 这里如果特征之间的数量级差别较大也是需要特征缩放的. (注:下图公式中$\alpha$后少了一个$1/m$)<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_86.png" alt="pic19"></p><h4 id="高级优化算法"><a href="#高级优化算法" class="headerlink" title="高级优化算法"></a>高级优化算法</h4><p>除了梯度下降还有其他更加高级更加复杂的算法：Conjugate Gradient、BFGS和L-BFGS. 如下图, 右下角是这些算法的优点和缺点。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_87.png" alt="pic20"><br>下图是一个具体的例子, 右边是自己定义的代价函数, 下方的options是调用fminunc所需的参数, initialTheta是初始的$\theta$，然后调用fminunc并传入相应的参数就可以得到最优的$\theta$。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_88.png" alt="pic21"><br>代价函数的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function [jVal, gradient] = costFunction(theta)</span><br><span class="line">jVal = (theta(1)-5)^2 + (theta(2)-5)^2;</span><br><span class="line">gradient = zeros(2,1);</span><br><span class="line">gradient(1) = 2*(theta(1)-5);</span><br><span class="line">gradient(2) = 2*(theta(2)-5);</span><br></pre></td></tr></table></figure></p><p>在Octave中演示如下:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_91.png" alt="pic22"></p><h4 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h4><p>下图举了一些多分类(Multiclass Classification)的例子<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_93.png" alt="pic23"><br>在之前的二分类(Binary Classification)的问题中, 我们的数据集大概是如下图左侧所示. 而现在的多分类(Multi-class Classification)的问题中数据集如下图左侧所示:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_94.png" alt="pic24"><br>我们可以使用一对多(One-vs-all/One-vs-rest)方法来处理这个问题, 即将其分成三个二分类的问题. 如下图所示:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_95.png" alt="pic25"><br>预测时, 需要计算出$h_\theta^{(1)}(x)$、$h_\theta^{(2)}(x)$、$h_\theta^{(3)}(x)$的值并得出最大值, 其对应的分类即为预测$x$的分类。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_96.png" alt="pic26"></p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home/week/3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Logistic Regression&lt;/a&gt;&lt;br&gt;课程Wiki：&lt;a href=&quot;https://share.coursera.org/wiki/index.php/ML:Logistic_Regression&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Logistic Regression&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;模型展示&quot;&gt;&lt;a href=&quot;#模型展示&quot; class=&quot;headerlink&quot; title=&quot;模型展示&quot;&gt;&lt;/a&gt;模型展示&lt;/h4&gt;&lt;h5 id=&quot;从线性回归解到对数几率回归&quot;&gt;&lt;a href=&quot;#从线性回归解到对数几率回归&quot; class=&quot;headerlink&quot; title=&quot;从线性回归解到对数几率回归&quot;&gt;&lt;/a&gt;从线性回归解到对数几率回归&lt;/h5&gt;&lt;p&gt;前面的课程中提到了一些分类问题:&lt;br&gt;&lt;img src=&quot;http://7xrrje.com1.z0.glb.clouddn.com/screenshot_68.png&quot; alt=&quot;pic01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
      <category term="Octave" scheme="http://yoursite.com/tags/Octave/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习笔记(四) - Octave教程</title>
    <link href="http://yoursite.com/2018/09/06/machine_learning_note_04/"/>
    <id>http://yoursite.com/2018/09/06/machine_learning_note_04/</id>
    <published>2018-09-06T15:38:08.933Z</published>
    <updated>2018-09-06T16:08:39.606Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><blockquote><p>课程地址：<a href="https://www.coursera.org/learn/machine-learning/lecture/9fHfl/basic-operations" target="_blank" rel="noopener">Octave Tutorial</a><br>课程Wiki：<a href="https://share.coursera.org/wiki/index.php/ML:Octave_Tutorial" target="_blank" rel="noopener">Octave Tutorial</a><br>参考：<a href="http://www.gnu.org/software/octave/doc/interpreter/" target="_blank" rel="noopener">Octave documentation pages</a>&emsp;&emsp;<a href="http://www.dm.unibo.it/~lenci/teaching/14/maa/octavetut.pdf" target="_blank" rel="noopener">Introduction to Octave</a></p></blockquote><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; 5+6</span><br><span class="line">ans =  11</span><br><span class="line">octave:2&gt; 3-2</span><br><span class="line">ans =  1</span><br><span class="line">octave:3&gt; 5*8</span><br><span class="line">ans =  40</span><br><span class="line">octave:4&gt; 1/2</span><br><span class="line">ans =  0.50000</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">octave:6&gt; 1 == 2</span><br><span class="line">ans = 0</span><br><span class="line">octave:7&gt; 1 ~= 2</span><br><span class="line">ans =  1</span><br><span class="line">octave:8&gt; 1 &amp;&amp; 0</span><br><span class="line">ans = 0</span><br><span class="line">octave:9&gt; 1 || 0</span><br><span class="line">ans =  1</span><br><span class="line">octave:10&gt; xor(1,0)</span><br><span class="line">ans =  1</span><br></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>更改提示符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:11&gt; PS1(&apos;&gt;&gt; &apos;)</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>添加分号可抑制输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = 1</span><br><span class="line">a =  1</span><br><span class="line">&gt;&gt; a = 1;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>圆周率$\pi$：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = pi</span><br><span class="line">a =  3.1416</span><br></pre></td></tr></table></figure></p><p>常数$e$：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; e</span><br><span class="line">ans =  2.7183</span><br></pre></td></tr></table></figure></p><p>格式化输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; disp(sprintf(&apos;6 decimals: %0.6f&apos;, a))</span><br><span class="line">6 decimals: 3.141593</span><br><span class="line">&gt;&gt; disp(sprintf(&apos;6 decimals: %0.2f&apos;, a))</span><br><span class="line">6 decimals: 3.14</span><br><span class="line">&gt;&gt; format long</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a =  3.14159265358979</span><br><span class="line">&gt;&gt; format short</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a =  3.1416</span><br></pre></td></tr></table></figure></p><h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p>构造一个矩阵，方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2; 3 4; 5 6;]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br></pre></td></tr></table></figure></p><p>构造一个矩阵，方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2;</span><br><span class="line">&gt; 3 4;</span><br><span class="line">&gt; 5 6;</span><br><span class="line">&gt; ]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br></pre></td></tr></table></figure></p><p>构造一个横向量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v = [1 2 3]</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br></pre></td></tr></table></figure></p><p>构造一个列向量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v = [1; 2; 3]</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br></pre></td></tr></table></figure></p><p>从1到2，每次递增0.1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v = 1:0.1:2</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line"> Columns 1 through 5:</span><br><span class="line"></span><br><span class="line">    1.0000    1.1000    1.2000    1.3000    1.4000</span><br><span class="line"></span><br><span class="line"> Columns 6 through 10:</span><br><span class="line"></span><br><span class="line">    1.5000    1.6000    1.7000    1.8000    1.9000</span><br><span class="line"></span><br><span class="line"> Column 11:</span><br><span class="line"></span><br><span class="line">    2.0000</span><br></pre></td></tr></table></figure></p><p>从1到6，每次递增1(默认)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v = 1:6</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   1   2   3   4   5   6</span><br></pre></td></tr></table></figure></p><p>所有元素均为1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ones(2, 3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   1   1</span><br><span class="line">   1   1   1</span><br></pre></td></tr></table></figure></p><p>每个元素乘以2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; C = 2*ones(2, 3)</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">   2   2   2</span><br><span class="line">   2   2   2</span><br></pre></td></tr></table></figure></p><p>高斯随机数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; rand(3, 3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   0.751588   0.906707   0.081204</span><br><span class="line">   0.411613   0.457779   0.882052</span><br><span class="line">   0.622524   0.774499   0.811092</span><br></pre></td></tr></table></figure></p><p>所有元素均为0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; w = zeros(1, 3)</span><br><span class="line">w =</span><br><span class="line"></span><br><span class="line">   0   0   0</span><br></pre></td></tr></table></figure></p><p>单位矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; I = eye(5)</span><br><span class="line">I =</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0   0   0</span><br><span class="line">   0   1   0   0   0</span><br><span class="line">   0   0   1   0   0</span><br><span class="line">   0   0   0   1   0</span><br><span class="line">   0   0   0   0   1</span><br></pre></td></tr></table></figure></p><p>读取矩阵A第三行第二列的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line">&gt;&gt; A(3, 2)</span><br><span class="line">ans =  6</span><br></pre></td></tr></table></figure></p><p>读取矩阵A第2列所有元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(:,2)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   4</span><br><span class="line">   6</span><br></pre></td></tr></table></figure></p><p>读取矩阵A第2行所有元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(2,:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   3   4</span><br></pre></td></tr></table></figure></p><p>读取矩阵A第1行和第3行的所有元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A([1 3],:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   5   6</span><br></pre></td></tr></table></figure></p><p>将A第二列替换为[10;11;12]：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(:,2) = [10; 11; 12]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">    1   10</span><br><span class="line">    3   11</span><br><span class="line">    5   12</span><br></pre></td></tr></table></figure></p><p>在A的最后加上一列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [A, [100; 101; 102]]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     1    10   100</span><br><span class="line">     3    11   101</span><br><span class="line">     5    12   102</span><br></pre></td></tr></table></figure></p><p>将A所有的元素合并成一个列向量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A(:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">     3</span><br><span class="line">     5</span><br><span class="line">    10</span><br><span class="line">    11</span><br><span class="line">    12</span><br><span class="line">   100</span><br><span class="line">   101</span><br><span class="line">   102</span><br></pre></td></tr></table></figure></p><p>两个矩阵的合并（列合并）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2; 3 4; 5 6]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B = [7 8; 9 10; 11 12]</span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">    7    8</span><br><span class="line">    9   10</span><br><span class="line">   11   12</span><br><span class="line"></span><br><span class="line">&gt;&gt; C = [A B]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    1    2    7    8</span><br><span class="line">    3    4    9   10</span><br><span class="line">    5    6   11   12</span><br></pre></td></tr></table></figure></p><p>两个矩阵的合并（行合并）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; D = [A;B]</span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">    1    2</span><br><span class="line">    3    4</span><br><span class="line">    5    6</span><br><span class="line">    7    8</span><br><span class="line">    9   10</span><br><span class="line">   11   12</span><br></pre></td></tr></table></figure></p><h5 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h5><p>构造10000个随机数，并绘制出图形(高斯分布)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; w=randn(1,10000);</span><br><span class="line">&gt;&gt; hist(w,50)</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/GaussianDistribution.png" alt="pic01"></p><h4 id="数据的读取和存储"><a href="#数据的读取和存储" class="headerlink" title="数据的读取和存储"></a>数据的读取和存储</h4><blockquote><p>本节所用到的数据: <a href="https://raw.githubusercontent.com/tansaku/py-coursera/master/featuresX.dat" target="_blank" rel="noopener">featuresX.dat</a>, <a href="https://raw.githubusercontent.com/tansaku/py-coursera/master/priceY.dat" target="_blank" rel="noopener">priceY.dat</a></p></blockquote><h5 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% 找到文件所在目录：</span><br><span class="line">&gt;&gt; cd Desktop/</span><br><span class="line">&gt;&gt; cd &apos;Machine Learning/&apos;</span><br><span class="line">&gt;&gt; ls</span><br><span class="line">featuresX.datpriceY.dat</span><br></pre></td></tr></table></figure><p>数据如下所示：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_599.png?imageMogr/v2/thumbnail/!45p" alt="pic02"><br>读取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 方式一：</span><br><span class="line">&gt;&gt; load featuresX.dat</span><br><span class="line">&gt;&gt; load priceY.dat</span><br><span class="line">% 方式二：</span><br><span class="line">&gt;&gt; load(&apos;featuresX.dat&apos;)</span><br><span class="line">&gt;&gt; load(&apos;priceY.dat&apos;)</span><br></pre></td></tr></table></figure></p><p>使用who命令显示当前所有变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; who</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">A          a          featuresX  v          y</span><br><span class="line">C          ans        priceY     w</span><br><span class="line">I          c          sz         x</span><br></pre></td></tr></table></figure></p><p>可以看到，刚才导入的数据已经在变量<code>featuresX</code>和<code>priceY</code>中了。<br>展示数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; featuresX</span><br><span class="line">featuresX =</span><br><span class="line"></span><br><span class="line">   2104      3</span><br><span class="line">   1600      3</span><br><span class="line">   2400      3</span><br><span class="line">   1416      2</span><br><span class="line">   3000      4</span><br><span class="line">   1985      4</span><br><span class="line">   1534      3</span><br><span class="line">    ...        ..</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(featuresX)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   27    2</span><br><span class="line"></span><br><span class="line">&gt;&gt; priceY</span><br><span class="line">priceY =</span><br><span class="line"></span><br><span class="line">   3999</span><br><span class="line">   3299</span><br><span class="line">   3690</span><br><span class="line">   2320</span><br><span class="line">   5399</span><br><span class="line">   2999</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(priceY)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   27    1</span><br></pre></td></tr></table></figure></p><p>使用如下命令用来删除某个变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clear featuresX</span><br><span class="line">&gt;&gt; whos</span><br></pre></td></tr></table></figure></p><h5 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h5><p>假设我们现在需要取出<code>priceY</code>前十个数据，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v = priceY(1:10)</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   3999</span><br><span class="line">   3299</span><br><span class="line">   3690</span><br><span class="line">   2320</span><br><span class="line">   5399</span><br><span class="line">   2999</span><br><span class="line">   3149</span><br><span class="line">   1989</span><br><span class="line">   2120</span><br><span class="line">   2425</span><br></pre></td></tr></table></figure></p><p>该如何存储这十个数据呢？使用<code>save</code>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; save hello.mat v</span><br><span class="line">&gt;&gt; ls</span><br><span class="line">featuresX.dathello.matpriceY.dat</span><br></pre></td></tr></table></figure></p><p>清空所有变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clear</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">&gt;&gt; %无任何输出</span><br></pre></td></tr></table></figure></p><p>刚才存储数据是以二进制的形式进行存储，我们也可以使用人能够读懂的形式存储。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; load hello.mat</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name        Size                     Bytes  Class</span><br><span class="line">   ==== ====        ====                     =====  =====</span><br><span class="line">        v          10x1                         80  double</span><br><span class="line"></span><br><span class="line">Total is 10 elements using 80 bytes</span><br><span class="line"></span><br><span class="line">&gt;&gt; v</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   3999</span><br><span class="line">   3299</span><br><span class="line">   3690</span><br><span class="line">   2320</span><br><span class="line">   5399</span><br><span class="line">   2999</span><br><span class="line">   3149</span><br><span class="line">   1989</span><br><span class="line">   2120</span><br><span class="line">   2425</span><br><span class="line"></span><br><span class="line">&gt;&gt; save hello.txt v -ascii</span><br><span class="line">&gt;&gt; ls</span><br><span class="line">featuresX.dathello.mathello.txtpriceY.dat</span><br></pre></td></tr></table></figure></p><h4 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% 各种矩阵运算</span><br><span class="line">&gt;&gt; A * B</span><br><span class="line">&gt;&gt; A .* B</span><br><span class="line">&gt;&gt; A .^ 2</span><br><span class="line">&gt;&gt; 1 ./ A</span><br><span class="line">&gt;&gt; log(A)</span><br><span class="line">&gt;&gt; exp(A)</span><br><span class="line">&gt;&gt; -A</span><br></pre></td></tr></table></figure><p>A中的每个元素都加上1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A + ones(size(A))</span><br></pre></td></tr></table></figure></p><p>这样也可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A + 1</span><br></pre></td></tr></table></figure></p><p>矩阵转置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A&apos;</span><br></pre></td></tr></table></figure></p><p>向量中的最大值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 3 0.5 10 100]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     1.00000     3.00000     0.50000    10.00000   100.00000</span><br><span class="line"></span><br><span class="line">&gt;&gt; [val ind] = max(A)</span><br><span class="line">val =  100</span><br><span class="line">ind =  5</span><br></pre></td></tr></table></figure></p><p>比较大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = [1 2; 3 4; 5 6]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A &gt; 3</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   0   0</span><br><span class="line">   0   1</span><br><span class="line">   1   1</span><br></pre></td></tr></table></figure></p><p>找出向量中特定元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; find(A &gt; 3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">   5</span><br><span class="line">   6</span><br></pre></td></tr></table></figure></p><p>找出矩阵中特定元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; [r c] = find(A &gt;= 3)</span><br><span class="line">r =</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">c =</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   2</span><br></pre></td></tr></table></figure></p><p>生成任意行、列、对角线和相等的矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; magic(3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br></pre></td></tr></table></figure></p><p>向量所有元素的和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; a = [1.2 2.3 4.5 6.6]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   1.2000   2.3000   4.5000   6.6000</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(a)</span><br><span class="line">ans =  14.600</span><br></pre></td></tr></table></figure></p><p>向上及向下取整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; floor(a)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   2   4   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; ceil(a)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   2   3   5   7</span><br></pre></td></tr></table></figure></p><p>构造一个由A,B两个矩阵中对应位置较大的数组成的矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B = [3 1; 4 6; 2 9]</span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">   3   1</span><br><span class="line">   4   6</span><br><span class="line">   2   9</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A, B)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   3   2</span><br><span class="line">   4   6</span><br><span class="line">   5   9</span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br></pre></td></tr></table></figure></p><p>取出矩阵每列最大的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; max(A, [], 1)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   5   6</span><br></pre></td></tr></table></figure></p><p>取出矩阵每行最大的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; max(A, [], 2)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   4</span><br><span class="line">   6</span><br></pre></td></tr></table></figure></p><p>想要直接获得矩阵中最大的元素，以下两种方式都可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 方式一：</span><br><span class="line">&gt;&gt; max(max(A))</span><br><span class="line">ans =  6</span><br><span class="line">% 方式二：</span><br><span class="line">&gt;&gt; max(A(:))</span><br><span class="line">ans =  6</span><br></pre></td></tr></table></figure></p><p>矩阵的上下翻转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; eye(3)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0</span><br><span class="line">   0   1   0</span><br><span class="line">   0   0   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; flipud(eye(3))</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">Permutation Matrix</span><br><span class="line"></span><br><span class="line">   0   0   1</span><br><span class="line">   0   1   0</span><br><span class="line">   1   0   0</span><br></pre></td></tr></table></figure></p><p>矩阵的逆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; A = rand(3, 3)</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   0.68934   0.12881   0.80507</span><br><span class="line">   0.49777   0.41907   0.37271</span><br><span class="line">   0.32607   0.27877   0.41814</span><br><span class="line"></span><br><span class="line">&gt;&gt; tmp = pinv(A)</span><br><span class="line">tmp =</span><br><span class="line"></span><br><span class="line">   1.795801   4.294380  -7.285421</span><br><span class="line">  -2.180466   0.647802   3.620828</span><br><span class="line">   0.053345  -3.780710   5.658801</span><br><span class="line"></span><br><span class="line">&gt;&gt; tmp * A</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1.00000   0.00000   0.00000</span><br><span class="line">   0.00000   1.00000   0.00000</span><br><span class="line">  -0.00000  -0.00000   1.00000</span><br></pre></td></tr></table></figure></p><h4 id="绘制数据"><a href="#绘制数据" class="headerlink" title="绘制数据"></a>绘制数据</h4><p>绘制出sin函数图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [0: 0.01: 0.98];</span><br><span class="line">&gt;&gt; y = sin(2*pi*4*x);</span><br><span class="line">&gt;&gt; plot(x,y);</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_602.png?imageMogr/v2/thumbnail/!55p" alt="pic03"><br>绘制出cos函数图像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y2 = cos(2*pi*4*x);</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_603.png?imageMogr/v2/thumbnail/!55p" alt="pic04"><br>将两个函数绘制在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; plot(x,y);</span><br><span class="line">&gt;&gt; hold on;</span><br><span class="line">&gt;&gt; plot(x,y2,&apos;r&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_604.png?imageMogr/v2/thumbnail/!55p" alt="pic05"><br>添加说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; xlabel(&quot;time&quot;);</span><br><span class="line">&gt;&gt; ylabel(&quot;value&quot;);</span><br><span class="line">&gt;&gt; lengend(&quot;sin&quot;, &quot;cos&quot;);</span><br><span class="line">error: &apos;lengend&apos; undefined near line 1 column 1</span><br><span class="line">&gt;&gt; legend(&quot;sin&quot;, &quot;cos&quot;);</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_605.png?imageMogr/v2/thumbnail/!55p" alt="pic06"><br>存储图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; print -dpng &quot;myPlot.png&quot;</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_606.png?imageMogr/v2/thumbnail/!55p" alt="pic07"><br>关掉绘制的图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; close</span><br></pre></td></tr></table></figure></p><p>分别在两个窗口显示两个图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; figure(1); plot(x, y);</span><br><span class="line">&gt;&gt; figure(2); plot(x, y2);</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_607.png?imageMogr/v2/thumbnail/!55p" alt="pic08"><br>改变左边图像的横坐标的刻度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; subplot(1,2,1)</span><br><span class="line">&gt;&gt; axis([0 0.5 -1 1])</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_608.png?imageMogr/v2/thumbnail/!55p" alt="pic09"><br>清除所有绘制的图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clf</span><br></pre></td></tr></table></figure></p><p>将矩阵可视化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; imagesc(magic(15))</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_609.png?imageMogr/v2/thumbnail/!55p" alt="pic10"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; imagesc(A), colorbar, colormap gray</span><br></pre></td></tr></table></figure></p><p><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_610.png?imageMogr/v2/thumbnail/!55p" alt="pic11"></p><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p>for循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; for i=1:10,</span><br><span class="line">&gt;      v(i) = i^2;</span><br><span class="line">&gt;  end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">     1     4     9    16    25    36    49    64    81   100</span><br></pre></td></tr></table></figure></p><p>while循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; i = 1;</span><br><span class="line">&gt;&gt; while i &lt;= 10,</span><br><span class="line">&gt;      v(i) = sqrt(v(i));</span><br><span class="line">&gt;</span><br><span class="line">Display all 1753 possibilities? (y or n)</span><br><span class="line">&gt;      i = i + 1;</span><br><span class="line">&gt;  end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    1    2    3    4    5    6    7    8    9   10</span><br></pre></td></tr></table></figure></p><p>定义一个函数：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_611.png?imageMogr/v2/thumbnail/!55p" alt="pic12"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ls</span><br><span class="line">featuresX.datmyPlot.pngsquareThisNumber.m</span><br><span class="line">hello.matoctave-workspace</span><br><span class="line">hello.txtpriceY.dat</span><br><span class="line">&gt;&gt; squareThisNumber(3)</span><br><span class="line">ans =  9</span><br></pre></td></tr></table></figure></p><p>如果该定义的函数不在当前目录下，我们就不能使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cd ~</span><br><span class="line">&gt;&gt; pwd</span><br><span class="line">ans = /Users/bobo</span><br><span class="line">&gt;&gt; squareThisNumber(3)</span><br><span class="line">error: &apos;squareThisNumber&apos; undefined near line 1 column 1</span><br></pre></td></tr></table></figure></p><p>不过我们也可以更改Octave的搜索路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; addpath(&quot;~/Desktop/Machine-Learning&quot;)</span><br></pre></td></tr></table></figure></p><p>更改之后，我们现在虽然在/User/bobo目录下，但是仍然可以使用squareThisNumber函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; pwd</span><br><span class="line">ans = /Users/bobo</span><br><span class="line">&gt;&gt; squareThisNumber(5)</span><br><span class="line">ans =  25</span><br></pre></td></tr></table></figure></p><p>返回两个值的函数：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_612.png?imageMogr/v2/thumbnail/!55p" alt="pic13"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; [y1, y2] = squareAndCube(3)</span><br><span class="line">y1 =  9</span><br><span class="line">y2 =  27</span><br></pre></td></tr></table></figure></p><p>代价函数：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_613.png?imageMogr/v2/thumbnail/!55p" alt="pic14"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; X = [1 1; 1 2; 1 3]</span><br><span class="line">X =</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   1   2</span><br><span class="line">   1   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; y = [1; 2; 3]</span><br><span class="line">y =</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; theta = [0; 1]</span><br><span class="line">theta =</span><br><span class="line"></span><br><span class="line">   0</span><br><span class="line">   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; costFunctionJ(X, y, theta)</span><br><span class="line">ans = 0</span><br></pre></td></tr></table></figure></p><p>如果$\theta=[0; 0]$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; theta = [0; 0]</span><br><span class="line">theta =</span><br><span class="line"></span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line"></span><br><span class="line">&gt;&gt; costFunctionJ(X, y, theta)</span><br><span class="line">ans =  2.3333</span><br></pre></td></tr></table></figure></p><h4 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h4><p><a href="https://www.coursera.org/learn/machine-learning/lecture/WnQWH/vectorization" target="_blank" rel="noopener">点击这里–&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/lecture/9fHfl/basic-operations&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octave Tutorial&lt;/a&gt;&lt;br&gt;课程Wiki：&lt;a href=&quot;https://share.coursera.org/wiki/index.php/ML:Octave_Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octave Tutorial&lt;/a&gt;&lt;br&gt;参考：&lt;a href=&quot;http://www.gnu.org/software/octave/doc/interpreter/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octave documentation pages&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;http://www.dm.unibo.it/~lenci/teaching/14/maa/octavetut.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Octave&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h4&gt;&lt;h5 id=&quot;四则运算&quot;&gt;&lt;a href=&quot;#四则运算&quot; class=&quot;headerlink&quot; title=&quot;四则运算&quot;&gt;&lt;/a&gt;四则运算&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;octave:1&amp;gt; 5+6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ans =  11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;octave:2&amp;gt; 3-2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ans =  1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;octave:3&amp;gt; 5*8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ans =  40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;octave:4&amp;gt; 1/2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ans =  0.50000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
      <category term="Octave" scheme="http://yoursite.com/tags/Octave/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习笔记(三) - 多变量线性回归</title>
    <link href="http://yoursite.com/2018/09/06/machine_learning_note_03/"/>
    <id>http://yoursite.com/2018/09/06/machine_learning_note_03/</id>
    <published>2018-09-06T07:04:35.958Z</published>
    <updated>2018-09-06T16:08:31.988Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><blockquote><p>课程地址：<a href="https://www.coursera.org/learn/machine-learning/lecture/6Nj1q/multiple-features" target="_blank" rel="noopener">Linear Regression with Multiple Variables</a><br>课程Wiki：<a href="https://share.coursera.org/wiki/index.php/ML:Linear_Regression_with_Multiple_Variables" target="_blank" rel="noopener">Linear Regression with Multiple Variables</a></p></blockquote><h4 id="假设函数-梯度下降"><a href="#假设函数-梯度下降" class="headerlink" title="假设函数 梯度下降"></a>假设函数 梯度下降</h4><h5 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h5><p>在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_36.png?imageMogr/v2/thumbnail/!55p" alt="pic01"></p><a id="more"></a><p>在实际问题中, 会有很多特征. 例如, 除了房子面积, 还有房子的卧室数量$x_2$，房子的楼层数$x_3$，房子建筑年龄$x_4$，其中$n$表示特征的数量，$m$表示训练样例的数量，$x^{(i)}$表示第$i$个训练样例，$x_j^{(i)}$表示第$i$个训练样例的第$j$个特征。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_37.png?imageMogr/v2/thumbnail/!55p" alt="pic02"><br>在单变量线性回归中假设函数为:<br>$${h_\theta(x)=\theta_0+\theta_1x}$$<br>类似地, 现在假设函数记作：<br>$${h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n}$$<br>可是每次这样写太麻烦了, 为了方便首先定义$x_0=1$（即$x_0^{(i)}=1$），此时$x_0^{(i)}=1$为：<br>$${h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n}$$<br>再令${\qquad\qquad\theta=\begin{bmatrix}\theta_0\ \theta_1\ \theta_2\.\.\.\ \theta_n \end{bmatrix}\in \rm I!R^{n+1}\quad,\qquad\qquad}$ ${x=\begin{bmatrix}x_0\x_1\x_2\.\.\.\x_n \end{bmatrix}\in \rm I!R^{n+1}}$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_829.png" alt="pic03"><br>这样就得到了假设函数的向量表示:<br>$${h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n= \theta^Tx}$$</p><h5 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h5><p>多变量情况下的梯度下降其实没有区别, 只需要把对应的偏导数项换掉即可。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_40.png?imageMogr/v2/thumbnail/!55p" alt="pic04"></p><h4 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h4><h5 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h5><p>如果每个特征的范围相差的很大, 梯度下降会很慢. 为了解决这个问题, 我们在梯度下降之前应该对数据做特征归缩放(Feature Scaling)处理，从而将所有的特征的数量级都在一个差不多的范围之内, 以加快梯度下降的速度。<br>假设现在我们有两个特征, 房子的面积和房间的数量. 如下图所示, 他们的范围相差的非常大. 对于这样的数据, 它的代价函数大概如下图左边, 梯度下降要经过很多很多次的迭代才能达到最优点. 如果我们对这两个特征按照右边给出的公式进行特征缩放, 那么此时的代价函数如下图右边所示, 相对于之前, 可以大大减少梯度下降的迭代次数。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_41.png?imageMogr/v2/thumbnail/!55p" alt="pic05"><br>通常我们需要把特征都缩放到$[-1,1]$（附近）这个范围。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_595.png?imageMogr/v2/thumbnail/!55p" alt="pic06"></p><h5 id="均值归一化"><a href="#均值归一化" class="headerlink" title="均值归一化"></a>均值归一化</h5><p>还有一个特征处理的方法就是均值归一化(Mean normalization):<br>$${x_i=\frac{x_i-\mu_i}{max-min}}$$<br>或者<br>$${x_i=\frac{x_i-\mu_i}{\sigma_i}}$$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_42.png?imageMogr/v2/thumbnail/!55p" alt="pic07"></p><h4 id="代价函数和学习率"><a href="#代价函数和学习率" class="headerlink" title="代价函数和学习率"></a>代价函数和学习率</h4><p>我们可以通过画出$\mathop{min}\limits_{\theta}J(\theta)$与迭代次数数的关系图来观察梯度下降的运行. 如下图所示, 横坐标是迭代次数, 纵坐标是代价函数的值. 如果梯度算法正常运行的话, 代价函数的图像大概的形状如下图所示。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_596.png?imageMogr/v2/thumbnail/!55p" alt="pic08"><br>还有一种叫自动收敛测试的方法, 即每次迭代之后观察$J(\theta)$，的值, 如果迭代之后下降的值小于$\epsilon$（例如$\epsilon=10^{-3}$），就判定为收敛. 不过准确地选择阈值$\epsilon$是非常困难的，通常还是使用画图的方法。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_597.png?imageMogr/v2/thumbnail/!55p" alt="pic09"><br>如果出现了下面的两种情况, 这个时候应该选择更小的$\alpha$，注意: 1.$\alpha$足够小, 那么$J(\theta)$在每次迭代之后都会减小；2.但是如果太小, 梯度下降会进行的非常缓慢。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_44.png?imageMogr/v2/thumbnail/!55p" alt="pic10"><br>可以使用下面几个值进行尝试<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_45.png?imageMogr/v2/thumbnail/!55p" alt="pic11"></p><h4 id="特征选择和多项式回归"><a href="#特征选择和多项式回归" class="headerlink" title="特征选择和多项式回归"></a>特征选择和多项式回归</h4><p>假设预测房屋价格, 选取房屋的长和宽作为变量, 得到如下的假设函数：<br>$$h(\theta)=\theta_0+\theta_1\times frontage+\theta_1\times depth$$<br>当然, 我们觉得真正决定房屋价格应该是与房屋的面积有关. 这时候我们也可以重新选择我们的特征$x=frontage\times depth$，此时的假设函数为：<br>$$h(\theta)=\theta_0+\theta_1x$$<br>通过这种特征的选择, 我们可能得到一个更好的模型<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_46.png?imageMogr/v2/thumbnail/!55p" alt="pic12"><br>和这个密切相关的一个概念就是多项式回归(Polynomial Regression). 假设有下图所示的关于房屋价格的数据集, 我们有多种模型去拟合(下图右所示). 第一个模型是一个二次函数, 但是二次函数是一个抛物线, 这里不符合(因为房价不会随着房子面积的增加二减小)；所以我们选择三次函数的模型, 想要使用该模型去拟合. 那么我们该如何将这个模型运用在我们的数据上呢？我们可以将房屋的面积作为第一个特征, 面积的平方作为第二个特征, 面积的立方作为第三个特征, 如下图左下角所示. (这里需要注意的是, $x_0,x_1,x_2$的范围差别会非常大, 所以一定要进行特征缩放处理）<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_47.png?imageMogr/v2/thumbnail/!55p" alt="pic13"><br>除了三次函数模型, 这里也可以选择平方根函数模型, 如下图所示<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_48.png?imageMogr/v2/thumbnail/!55p" alt="pic14"></p><h4 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h4><h5 id="正规方程-1"><a href="#正规方程-1" class="headerlink" title="正规方程"></a>正规方程</h5><p>之前我们一直是用的梯度下降求解最优值. 它的缺点就是需要进行很多次迭代才能得到全局最优解. 有没有更好的方法呢? 我们先来看一个最简单的例子, 假设现在的代价函数为$J(\theta)=a\theta^2+b\theta+c$，$\theta$是一个实数. 怎样得到最优解? 很简单, 只要令它的导数为0就可以了。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_56.png?imageMogr/v2/thumbnail/!55p" alt="pic15"><br>事实上, 代价函数不会像例子那样简单, $\theta$也不是一个实数，而是一个$n+1$维的向量，这样, 我们分别对每个$\theta$求偏导，再令偏导等于0, 可以计算出左右的$\theta$，了. 但看上去还是很繁琐, 所以下面我们介绍一种向量化的求解方法。<br>首先, 在数据集前加上一列$x_0$，值都为1；然后将所有的变量都放入矩阵$X$中(包括加上的$x_0$)；再将输出值放入向量$y$中。最后通过公式$\theta=(X^TX)^{-1}X^Ty$，就可以算出$\theta$的值。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_57.png?imageMogr/v2/thumbnail/!55p" alt="pic16"><br>下图是一个更通用的表达方式：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_58.png?imageMogr/v2/thumbnail/!55p" alt="pic17"><br>在Octave中, 可用如下命令计算:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pinv(x&apos;*x)*x&apos;*y</span><br></pre></td></tr></table></figure></p><p>这个公式叫做正规方程, 使用这种方法还有一个好处就是不需要进行特征缩放处理。</p><h5 id="梯度下降与正规方程的比较"><a href="#梯度下降与正规方程的比较" class="headerlink" title="梯度下降与正规方程的比较"></a>梯度下降与正规方程的比较</h5><p>下图是梯度下降(Gradient Descent)和正规方程(Normal Equation)两种方法优缺点的比较：<br>梯度下降 | 正规方程</p><ul><li>| -<br>需要选择学习率$\alpha$ | 不需要选择学习率$\alpha$<br>需要很多次迭代 | 不需要迭代<br>当有大量特征时, 也能正常工作 | 需要计算$(X^TX)^{-1}$$O(n^3)$， n非常大时, 计算非常慢<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_59.png?imageMogr/v2/thumbnail/!55p" alt="pic18"></li></ul><h5 id="正规方程不可逆的情况"><a href="#正规方程不可逆的情况" class="headerlink" title="正规方程不可逆的情况"></a>正规方程不可逆的情况</h5><p>使用正规方程还有一个问题就是$X^TX$可能存在不可逆的情况。这个时候, 可能是因为我们使用了冗余的特征, 还有一个原因是我们使用了太多的特征(特征的数量超过了样本的数量)。对于这种情况我们可以删掉一些特征或者使用正则化(正则化在后面的课中讲)。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_830.png" alt="pic19"></p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/lecture/6Nj1q/multiple-features&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linear Regression with Multiple Variables&lt;/a&gt;&lt;br&gt;课程Wiki：&lt;a href=&quot;https://share.coursera.org/wiki/index.php/ML:Linear_Regression_with_Multiple_Variables&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linear Regression with Multiple Variables&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;假设函数-梯度下降&quot;&gt;&lt;a href=&quot;#假设函数-梯度下降&quot; class=&quot;headerlink&quot; title=&quot;假设函数 梯度下降&quot;&gt;&lt;/a&gt;假设函数 梯度下降&lt;/h4&gt;&lt;h5 id=&quot;假设函数&quot;&gt;&lt;a href=&quot;#假设函数&quot; class=&quot;headerlink&quot; title=&quot;假设函数&quot;&gt;&lt;/a&gt;假设函数&lt;/h5&gt;&lt;p&gt;在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征:&lt;br&gt;&lt;img src=&quot;http://7xrrje.com1.z0.glb.clouddn.com/screenshot_36.png?imageMogr/v2/thumbnail/!55p&quot; alt=&quot;pic01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>《极恶非道》观后感</title>
    <link href="http://yoursite.com/2018/09/05/jiefeidao_comment/"/>
    <id>http://yoursite.com/2018/09/05/jiefeidao_comment/</id>
    <published>2018-09-05T14:18:06.603Z</published>
    <updated>2018-09-05T14:18:06.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无关乎生存，仅在乎利益。这是电影交代的黑帮从上而下的恶，这种恶充斥了整部电影，不仅黑帮，也有警察。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-3dec37c2122bb378247032a377f957d4_qhd.jpg" alt="北野武照片"></p><p>北野武是以拍摄黑帮片出道，早期的《奏鸣曲》是一部故事完全发生黑帮内部的电影，但北野武没有把电影拍成类型化的模式，而是嚼碎了各种类型化的元素，为之注入了他个人独特的对于荒诞生命的严峻思考。2000年赴美拍摄的《大佬》倒是比较类型化，影片不断展示帮派战斗的过程，还充满了东西方文化的差异比较，生死相托的日式侠义精神在影片中被反复讴歌。<br><a id="more"></a><br>《极恶非道》是北野武十年后回归暴力黑社会的作品。影片的叙事法则便是你来我往的夺权战斗。叙事出发点始于关内会长（北村总一朗 扮）要抢夺村濑（石桥莲司 扮）组的地盘，用的策略是并不高明的挑拨离间，让曾经与村濑为狱友的池元（国村隼 扮）与之大战。池元手下的大友（北野武 扮）组与村濑组的木村（中野英雄 扮）也随之展开斗争。这是一部众生相电影，与之相关的重要角色还有大友组的石原（加濑亮 扮）、水野（椎名桔平 扮），会长手下的加藤（三浦友和 扮），负责暴力团事物的警察片冈。影片的日文片名直译是《全员恶人》，这里面确实没有一个道德方面的善良之辈，没有英雄，只有恶人。尤其是几个首领，关内会长、池元、村濑，没有任何道义和领袖魅力可言，有的只是利欲熏心。过往日本黑帮组织的一些情义亦是荡然无存。池元与村濑本来是狱友，在《无仁义之战》第一集中，狱友曾经是被表现为敢用性命相托的赤胆忠诚之关系，在本片中却是一文不值，面对质问，池元甚至说，“拜把只是个仪式”。木村连切手指都不敢。而当大友当真用切手指的方法道歉时，却被会长讥讽这过时了，“老套的切手指没有用”。在此特别值得一提的是北野扮演的大友这个角色，正是这个角色的存在为这部黑帮片注入了一些别样的独属于北野武式思考的活力。</p><p>大友在影片虽亦是热衷暴力的恶人，但在道义上却是偏向正面。他当真视池元为干爹，为其卖命，但随后看透了这套把戏之后，意识到这是一场你死我活的战斗。黑帮中人，本来已经看透生死，当意识到道之不存后，大友便将这场战斗看成了无关道义的死亡游戏。死亡到来的时刻便是当下澄明的解脱时刻，这是北野武式洒脱豁达当下即是的生命哲学。正是这个视点又为这部类型化程度很高的黑帮电影，注入了一种抽离的客观化的视点。也正是在北野武独特生命哲学的关照之下，与死亡密切相关的暴力，被北野武表达的如此极致。北野武多年来的采访中曾多次表达了个人对暴力的看法，他讨厌美感的暴力，他认为暴力的本质就是伤痛，“暴力就是暴力，我希望用暴力的镜头刺痛观众，让他们知道暴力有多么糟糕，所以我不会顾忌该用什么样的方式，用多野蛮的力度。也许你们看电影的时候，已经觉得承受不了了，但其实这是我故意制造出来的，我希望让观众感到剧烈的疼痛和恐惧，这种感觉就是暴力的本质。我最讨厌那种把暴力拍得很美的电影，还冠以暴力美学的美称，那样的电影才是教坏小孩子的罪魁祸首”。吴宇森式的自我崇高化的浪漫暴力，或者塔伦蒂诺式卡通恶趣味暴力，在北野武的电影中是看不到的。瞬间爆发的，极致的，带来无比伤痛的暴力才是真正的北野暴力。在《极恶非道》系列中，北野勾画出的暴力类型亦是极端残酷：电钻凿牙齿、筷子猛插耳朵、猛击舌头导致卡舌而死、棒球连续性地击砸面门。最汹涌澎湃的无情暴力莫过于与大友并肩作战到最后的水野：头颅被绳子套住后飞车拉断而死。</p><p>《极恶非道》系列第二集的主题与叙事模式与第一集类似，只是权斗的始作俑者变成了警察片冈。警方这套挑拨离间以暴易暴的制敌模式也是其来有自。1987年，一和会与山口组发生了激烈的暴力抗争。当时，一合会打算在大阪地区刺杀新上任的山口组组长竹中正久，他们用了二十多部无线电对讲机。关西电信局发现情况后报警，但警方不予理睬，为的就是帮助一合会行刺，以暴易暴。不过片冈在影片中并非正义人士，而是猥琐的敲诈犯，当大友看破这死局后，二话不说一枪击毙片冈。影片的高潮来得猝不及防，但却酣畅淋漓，激越又超然。</p><p>这是一部非常纯正的yakuza电影，而电影中表现的暴力和深作欣二的热血翻滚不同，北野武的暴力凝固至冰点，让人看完脊背发凉。</p><blockquote><p>最激烈的暴力与死亡冲动同样可以是最深邃的生命顿悟。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无关乎生存，仅在乎利益。这是电影交代的黑帮从上而下的恶，这种恶充斥了整部电影，不仅黑帮，也有警察。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3dec37c2122bb378247032a377f957d4_qhd.jpg&quot; alt=&quot;北野武照片&quot;&gt;&lt;/p&gt;
&lt;p&gt;北野武是以拍摄黑帮片出道，早期的《奏鸣曲》是一部故事完全发生黑帮内部的电影，但北野武没有把电影拍成类型化的模式，而是嚼碎了各种类型化的元素，为之注入了他个人独特的对于荒诞生命的严峻思考。2000年赴美拍摄的《大佬》倒是比较类型化，影片不断展示帮派战斗的过程，还充满了东西方文化的差异比较，生死相托的日式侠义精神在影片中被反复讴歌。&lt;br&gt;
    
    </summary>
    
      <category term="影评" scheme="http://yoursite.com/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="北野武" scheme="http://yoursite.com/tags/%E5%8C%97%E9%87%8E%E6%AD%A6/"/>
    
      <category term="yakuza" scheme="http://yoursite.com/tags/yakuza/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习笔记(二) - 单变量线性回归(补充 - 梯度下降算法)</title>
    <link href="http://yoursite.com/2018/09/05/machine_learning_note_02_addition/"/>
    <id>http://yoursite.com/2018/09/05/machine_learning_note_02_addition/</id>
    <published>2018-09-05T13:51:57.176Z</published>
    <updated>2018-09-05T13:53:58.677Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\theta_0$、$\theta_1$。它的思想是, 首先随机选择两个$\theta_0$、$\theta_1$，不断地改变它们的值使得$J(\theta_0,\theta_1)$变小，最终找到$J(\theta_0,\theta_1)$的最小值。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_21.png?imageMogr/v2/thumbnail/!45p" alt="pic01"></p><a id="more"></a><p>可以把梯度下降的过程想象成下山坡, 如果想要尽可能快的下坡, 应该每次都往坡度最大的方向下山。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_22.png?imageMogr/v2/thumbnail/!45p" alt="pic02"><br>梯度下降算法得到的结果会受到初始状态的影响, 即当从不同的点开始时, 可能到达不同的局部极小值, 如下图:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_23.png?imageMogr/v2/thumbnail/!45p" alt="pic03"><br>下面具体看一下算法的过程, 如下图所示, 其中$:=$表示赋值，$\alpha$表示学习率用来控制下降的幅度，$\frac{\partial}{\partial\theta_j}J(\theta_0, \theta_1)$表示梯度。这里一定要注意的是，算法每次是同时(simultaneously)改变$\theta_0$和$\theta_1$的值，如下图所示<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_24.png?imageMogr/v2/thumbnail/!45p" alt="pic04"></p><h4 id="梯度和学习率"><a href="#梯度和学习率" class="headerlink" title="梯度和学习率"></a>梯度和学习率</h4><p>我们先来看看梯度下降算法的梯度是如何帮助我们找到最优解的. 为了研究问题的方便我们还是同样地令$\theta_0=0$，假设一开始选取的$\theta_1$在最低点右侧，此时的梯度(斜率)是一个正数。根据上面的算法更新$\theta_1$的时候，它的值会减小, 即靠近最低点。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_26.png?imageMogr/v2/thumbnail/!45p" alt="pic05"><br>类似地假设一开始选取的$\theta_1$在最低点的左侧，此时的梯度是一个负数，根据上面的算法更新$\theta_1$的时候，它的值会增大，也会靠近最低点。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_27.png?imageMogr/v2/thumbnail/!45p" alt="pic06"><br>如果一开始选取的$\theta_1$恰好在最适位置，那么更新$\theta_1$时，它的值不会发生变化。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_29.png?imageMogr/v2/thumbnail/!45p" alt="pic07"><br>学习率$\alpha$会影响梯度下降的幅度。如果$\alpha$太小，$\theta$的值每次会变化的很小，那么梯度下降就会非常慢；相反地，如果$\alpha$太大，$\theta$的值每次会变化的很大，有可能直接越过最低点，可能导致永远没法到达最低点。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_28.png?imageMogr/v2/thumbnail/!45p" alt="pic08"><br>由于随着越来越接近最低点, 相应的梯度(绝对值)也会逐渐减小，所以每次下降程度就会越来越小, 我们并不需要减小$\alpha$的值来减小下降程度。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_31.png?imageMogr/v2/thumbnail/!45p" alt="pic09"></p><h4 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h4><p>根据定义, 梯度也就是代价函数对每个$\theta$求偏导：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_585.png?imageMogr/v2/thumbnail/!45p" alt="pic10"><br>我们将$h_\theta(x^{(i)})=\theta_0+\theta_1x^{(i)}$带入到$J(\theta_0,\theta_1)$中，并且分别对$\theta_0$，$\theta_1$求导得：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_32.png?imageMogr/v2/thumbnail/!45p" alt="pic11"><br>由此得到了完整的梯度下降算法:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_33.png?imageMogr/v2/thumbnail/!45p" alt="pic12"><br>前面说了梯度下降算法得到的结果会受初始状态的影响, 即初始状态不同, 结果可能是不同的局部最低点。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_23.png?imageMogr/v2/thumbnail/!45p" alt="pic13"><br>事实上，用于线性回归的代价函数总是一个凸函数(Convex Function)。这样的函数没有局部最优解，只有一个全局最优解。所以我们在使用梯度下降的时候，总会得到一个全局最优解。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_16.png?imageMogr/v2/thumbnail/!45p" alt="pic14"><br>下面我们来看一下梯度下降的运行过程：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_586.png?imageMogr/v2/thumbnail/!45p" alt="pic15"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_587.png?imageMogr/v2/thumbnail/!45p" alt="pic16"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_588.png?imageMogr/v2/thumbnail/!45p" alt="pic17"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_589.png?imageMogr/v2/thumbnail/!45p" alt="pic18"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_590.png?imageMogr/v2/thumbnail/!45p" alt="pic19"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_592.png?imageMogr/v2/thumbnail/!45p" alt="pic20"><br>迭代多次后，我们得到了最优解。现在我们可以用最优解对应的假设函数来对房价进行预测了。例如一个1,250平方英尺的房子大概能卖到250k$，如下图所示：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_593.png?imageMogr/v2/thumbnail/!45p" alt="pic21"></p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;h4 id=&quot;梯度下降&quot;&gt;&lt;a href=&quot;#梯度下降&quot; class=&quot;headerlink&quot; title=&quot;梯度下降&quot;&gt;&lt;/a&gt;梯度下降&lt;/h4&gt;&lt;p&gt;梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\theta_0$、$\theta_1$。它的思想是, 首先随机选择两个$\theta_0$、$\theta_1$，不断地改变它们的值使得$J(\theta_0,\theta_1)$变小，最终找到$J(\theta_0,\theta_1)$的最小值。&lt;br&gt;&lt;img src=&quot;http://7xrrje.com1.z0.glb.clouddn.com/screenshot_21.png?imageMogr/v2/thumbnail/!45p&quot; alt=&quot;pic01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习笔记(二) - 单变量线性回归</title>
    <link href="http://yoursite.com/2018/09/04/machine_learning_note_02/"/>
    <id>http://yoursite.com/2018/09/04/machine_learning_note_02/</id>
    <published>2018-09-04T14:27:55.458Z</published>
    <updated>2018-09-06T16:07:48.039Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><blockquote><p>课程地址：<a href="https://www.coursera.org/learn/machine-learning/home/week/1" target="_blank" rel="noopener">Linear Regression with One Variable</a><br>课程Wiki：<a href="https://share.coursera.org/wiki/index.php/ML:Linear_Regression_with_One_Variable" target="_blank" rel="noopener">Linear Regression with One Variable</a></p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h5><p>由训练样例(training example)组成的集合就是训练集(training set)，如下图所示, 其中$(x, y)$是一个训练样例, $(x^{(i)}, y^{(i)})$第i个训练样例。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_05.png?imageMogr/v2/thumbnail/!45p" alt="pic01"></p><a id="more"></a><h5 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h5><p>使用某种学习算法对训练集的数据进行训练, 我们可以得到假设函数(Hypothesis Function), 如下图所示. 在房价的例子中，假设函数就是一个房价关于房子面积的函数。有了这个假设函数之后, 给定一个房子的面积我们就可以预测它的价格了。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_583.png?imageMogr/v2/thumbnail/!55p" alt="pic02"><br>我们使用如下的形式表示假设函数, 为了方便，$h_\theta(x)$也可以记作$h(x)$<br>$${h_\theta(x)=\theta_0+\theta_1x}$$<br>以上这个模型就叫做单变量的线性回归(Linear Regression with One Variable). (Linear regression with one variable = Univariate linear regression，univariate是one variable的装逼写法。)<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_584.png?imageMogr/v2/thumbnail/!55p" alt="pic03"></p><h4 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h4><h5 id="什么是代价函数"><a href="#什么是代价函数" class="headerlink" title="什么是代价函数"></a>什么是代价函数</h5><p>只要我们知道了假设函数, 我们就可以进行预测了. 关键是, 假设函数中有两个未知的量$\theta_0, \theta_1$，当选择不同的$\theta_0$和$\theta_1$时，我们模型的效果肯定是不一样的。如下图所示, 列举了三种不同的$\theta_0$和$\theta_1$下的假设函数。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_08.png" alt="pic04"><br>现在的问题就是该如何选择这两个参数了。我们的想法是选择某个$\theta_0$和$\theta_1$，使得对于训练样例$(x,y)$，$h_\theta(x)$最接近$y$。越是接近, 代表这个假设函数越是准确, 这里我们选择均方误差来作为衡量标准, 即我们想要每个样例的估计值与真实值之间差的平方的均值最小。用公式表达为:<br>$${\mathop{minimize}\limits_{\theta_0,\theta_1} \frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}$$<br>（其中$1/2$是为了后面方便计算）我们记<br>$${J(\theta_0,\theta_1)=\frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}$$<br>这样就得到了我们的代价函数(cost function), 也就是我们的优化目标, 我们想要代价函数最小:<br>$$\mathop{minimize}\limits_{\theta_0,\theta_1}J(\theta_0,\theta_1)$$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_10.png?imageMogr/v2/thumbnail/!45p" alt="pic05"></p><h5 id="代价函数和假设函数"><a href="#代价函数和假设函数" class="headerlink" title="代价函数和假设函数"></a>代价函数和假设函数</h5><p>现在为了更方便地探究$h_\theta(x)$和$J(\theta_0,\theta_1)$的关系，先令$\theta_0=0$，得到了简化后的假设函数，有假设函数的定义可知此时的假设函数是经过原点的直线. 相应地也也得到简化的代价函数。如图所示:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_11.png?imageMogr/v2/thumbnail/!45p" alt="pic06"><br>简化之后，我们令$\theta_1=1$，就得到$h_\theta(x)=x$，如下图左所示。图中三个红叉表示训练样例，通过代价函数的定义我们计算得出$J(1)=0$，对应下图右中的$(0,1)$坐标<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_12.png?imageMogr/v2/thumbnail/!45p" alt="pic07"><br>重复上面的步骤，再令$\theta_1=0.5$，得到$h_\theta(x)$如下图左所示。通过计算得出$J(0.5)=0.58$，对应下图右中的$(0.5,0.58)$<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_13.png?imageMogr/v2/thumbnail/!45p" alt="pic08"><br>对于不同的$\theta_1$，对应着不同的假设函数$h_\theta(x)$，于是就有了不同的$J(\theta_1)$。将这些点连接起来就可以得到$J(\theta_1)$关于$\theta_1$的函数图像，如下图所示：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_14.png?imageMogr/v2/thumbnail/!45p" alt="pic09"><br>我们的目标就是找到一个$\theta$使得$J(\theta)$最小，通过上面的描点作图的方式, 我们可以从图中看出, 当$\theta=1$的时候，$J(\theta)$取到最小值。</p><h5 id="代价函数与假设函数II"><a href="#代价函数与假设函数II" class="headerlink" title="代价函数与假设函数II"></a>代价函数与假设函数II</h5><p>在上一节中，我们令$\theta_0=0$，并且通过设置不同的$\theta_1$来描点作图得到$J(\theta_1)$的曲线。这一节我们不再令$\theta_0=0$，而是同时设置$\theta_0$和$\theta_1$的值，然后再绘出$J(\theta_0, \theta_1)$的图形。因为此时有两个变量，很容易想到$J(\theta_0, \theta_1)$应该是一个曲面, 如下图所示:<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_16.png?imageMogr/v2/thumbnail/!45p" alt="pic10"><br>这个图是教授用matlab绘制的，由于3D图形不太方便我们研究，我们就使用二维的等高线(上图右上角教授写的contour plots/figures)，这样看上去比较清楚一些。如下图右，越靠近中心表示$J(\theta_0, \theta_1)$的值越小(对应3D图中越靠近最低点的位置)。下图左表示当$\theta_0=800$，$\theta_1=0.15$的时候对应的$h_\theta(x)$，通过$\theta_0$和$\theta_1$的值可以找到下图右中$J(\theta_0, \theta_1)$的值。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_17.png?imageMogr/v2/thumbnail/!45p" alt="pic11"><br>类似地：<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_18.png?imageMogr/v2/thumbnail/!45p" alt="pic12"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_19.png?imageMogr/v2/thumbnail/!45p" alt="pic13"><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_20.png?imageMogr/v2/thumbnail/!45p" alt="pic14"><br>我们不断尝试直到找到一个最佳的$h_\theta(x)$。是否有特定的算法能帮助我们找到最佳的$h_\theta(x)$呢？下面我们就要介绍这个算法-<a href="https://bigmoutain.cn/2018/09/05/machine_learning_note_02_addition/" target="_blank" rel="noopener">梯度下降算法</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}
});
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;


&lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home/week/1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linear Regression with One Variable&lt;/a&gt;&lt;br&gt;课程Wiki：&lt;a href=&quot;https://share.coursera.org/wiki/index.php/ML:Linear_Regression_with_One_Variable&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linear Regression with One Variable&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;h5 id=&quot;训练集&quot;&gt;&lt;a href=&quot;#训练集&quot; class=&quot;headerlink&quot; title=&quot;训练集&quot;&gt;&lt;/a&gt;训练集&lt;/h5&gt;&lt;p&gt;由训练样例(training example)组成的集合就是训练集(training set)，如下图所示, 其中$(x, y)$是一个训练样例, $(x^{(i)}, y^{(i)})$第i个训练样例。&lt;br&gt;&lt;img src=&quot;http://7xrrje.com1.z0.glb.clouddn.com/screenshot_05.png?imageMogr/v2/thumbnail/!45p&quot; alt=&quot;pic01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习笔记(一) - 监督学习vs无监督学习</title>
    <link href="http://yoursite.com/2018/09/04/machine_learning_note_01/"/>
    <id>http://yoursite.com/2018/09/04/machine_learning_note_01/</id>
    <published>2018-09-04T14:03:23.953Z</published>
    <updated>2018-09-06T16:07:16.164Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程地址：<a href="https://www.coursera.org/learn/machine-learning/lecture/1VkCb/supervised-learning" target="_blank" rel="noopener">Supervised Learning &amp; Unsupervised Learning</a><br>课程Wiki：<a href="https://share.coursera.org/wiki/index.php/ML:Introduction" target="_blank" rel="noopener">Introduction</a></p></blockquote><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>什么是监督学习? 我们来看看维基百科中给出的定义:</p><blockquote><p>监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）</p></blockquote><p>从数据的角度来讲, 监督学习和无监督学习的区别就在于监督学习的数据不仅仅有特征组成, 即每一个数据样本都包含一个准确的输出值. 在房价预测的问题中, 数据由特征+房价组成。</p><a id="more"></a><h5 id="监督学习的分类"><a href="#监督学习的分类" class="headerlink" title="监督学习的分类"></a>监督学习的分类</h5><p>在监督学习中, 我们的预测结果可以是连续值, 也可以是离散值。我们根据这样的属性将监督学习分为回归问题和分类问题。<br>下面我们分别举一个例子来看看, 学完这两个例子之后, 我们就会对监督学习, 回归以及分类有比较清晰地认识了。</p><h5 id="监督学习举例"><a href="#监督学习举例" class="headerlink" title="监督学习举例"></a>监督学习举例</h5><h6 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h6><p>我们现在有这么一个问题, 我们想通过给定的一个房子的面积来预测这个房子在市场中的价格。这里的房子的面积就是特征, 房子的价格就是一个输出值。为了解决这个问题, 我们获取了大量的房地产数据, 每一条数据都包含房子的面积及其对应价格. 第一, 我们的数据不仅包含房屋的面积, 还包含其对应的价格, 而我们的目标就是通过面积预测房价。所以这应该是一个监督学习; 其次, 我们的输出数据房价可以看做是连续的值, 所以这个问题是一个回归问题。至于如何通过数据得到可以使用的模型, 后面的几节课再做讨论。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_1.jpg?imageMogr/v2/thumbnail/!45p" alt="pic01"></p><h6 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h6><p>再来看一个分类问题, 从名字上来讲, 分类问题还是比较好理解的, 我们的目标应该是要对数据进行分类。现在我们的数据是有关乳腺癌的医学数据, 它包含了肿瘤的大小以及该肿瘤是良性的还是恶性的。我们的目标是给定一个肿瘤的大小来预测它是良性还是恶性. 我们可以用0代表良性，1代表恶性。这就是一个分类问题, 因为我们要预测的是一个离散值。当然, 在这个例子中, 我们的离散值可以去’良性’或者’恶性’. 在其他分类问题中, 离散值可能会大于两个。例如在该例子中可以有{0,1,2,3}四种输出，分别对应{良性, 第一类肿瘤, 第二类肿瘤, 第三类肿瘤}。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_1022aa.jpg?imageMogr/v2/thumbnail/!45p" alt="pic02"><br>在这个例子中特征只有一个即瘤的大小。 对于大多数机器学习的问题, 特征往往有多个(上面的房价问题也是, 实际中特征不止是房子的面积)..例如下图， 有“年龄”和“肿瘤大小”两个特征。(还可以有其他许多特征，如下图右侧所示)<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_1018abc.jpg?imageMogr/v2/thumbnail/!45p" alt="pic03"></p><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>在监督学习中我们也提到了它与无监督学习的区别。在无监督学习中, 我们的数据并没有给出特定的标签, 例如上面例子中的房价或者是良性还是恶性。我们目标也从预测某个值或者某个分类便成了寻找数据集中特殊的或者对我们来说有价值结构。如下图所示, 我们可以直观的感受到监督学习和无监督学习在数据集上的区别。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/screenshot_582.png?imageMogr/v2/thumbnail/!55p" alt="pic04"><br>我们也可以从图中看到, 大概可以将数据及分成两个簇。将数据集分成不同簇的无监督学习算法也被称为聚类算法。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_1025dadc.jpg?imageMogr/v2/thumbnail/!45p" alt="pic05"></p><h5 id="无监督学习举例"><a href="#无监督学习举例" class="headerlink" title="无监督学习举例"></a>无监督学习举例</h5><h6 id="新闻分类"><a href="#新闻分类" class="headerlink" title="新闻分类"></a>新闻分类</h6><p>第一个例子举的是Google News的例子。Google News搜集网上的新闻，并且根据新闻的主题将新闻分成许多簇, 然后将在同一个簇的新闻放在一起。如图中红圈部分都是关于BP Oil Well各种新闻的链接，当打开各个新闻链接的时候，展现的都是关于BP Oil Well的新闻。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_0168.png?imageMogr/v2/thumbnail/!45p" alt="pic06"></p><h6 id="根据给定基因将人群分类"><a href="#根据给定基因将人群分类" class="headerlink" title="根据给定基因将人群分类"></a>根据给定基因将人群分类</h6><p>如图是DNA数据，对于一组不同的人我们测量他们DNA中对于一个特定基因的表达程度。然后根据测量结果可以用聚类算法将他们分成不同的类型。<br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_0169.png?imageMogr/v2/thumbnail/!45p" alt="pic07"></p><h6 id="鸡尾酒排队效应"><a href="#鸡尾酒排队效应" class="headerlink" title="鸡尾酒排队效应"></a>鸡尾酒排队效应</h6><p>详见课程: <a href="https://www.coursera.org/learn/machine-learning/lecture/olRZo/unsupervised-learning" target="_blank" rel="noopener">Unsupervised Learning</a></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p>这里又举了其他几个例子，有组织计算机集群，社交网络分析，市场划分，天文数据分析等。具体可以看一下视频：<a href="https://www.coursera.org/learn/machine-learning/lecture/olRZo/unsupervised-learning" target="_blank" rel="noopener">Unsupervised Learning</a><br><img src="http://7xrrje.com1.z0.glb.clouddn.com/img_1024abc.jpg?imageMogr/v2/thumbnail/!45p" alt="pic08"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/lecture/1VkCb/supervised-learning&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Supervised Learning &amp;amp; Unsupervised Learning&lt;/a&gt;&lt;br&gt;课程Wiki：&lt;a href=&quot;https://share.coursera.org/wiki/index.php/ML:Introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h4&gt;&lt;p&gt;什么是监督学习? 我们来看看维基百科中给出的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从数据的角度来讲, 监督学习和无监督学习的区别就在于监督学习的数据不仅仅有特征组成, 即每一个数据样本都包含一个准确的输出值. 在房价预测的问题中, 数据由特征+房价组成。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>机器学习资料整理</title>
    <link href="http://yoursite.com/2018/09/03/machine_learning_materials/"/>
    <id>http://yoursite.com/2018/09/03/machine_learning_materials/</id>
    <published>2018-09-03T10:38:41.948Z</published>
    <updated>2018-09-03T11:26:46.850Z</updated>
    
    <content type="html"><![CDATA[<h4 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h4><p>&emsp;&emsp;<a href="https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/" target="_blank" rel="noopener">Single Variable Calculus - MIT</a></p><h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p>&emsp;&emsp;<a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/" target="_blank" rel="noopener">Linear Algebra - MIT</a><br><a id="more"></a></p><h4 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h4><p>&emsp;&emsp;(暂无)</p><h4 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h4><p>&emsp;&emsp;(暂无)</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>&emsp;&emsp;<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰Python教程</a><br>&emsp;&emsp;<a href="https://learnxinyminutes.com/docs/zh-cn/python3-cn/" target="_blank" rel="noopener">Learn python in Y minutes</a></p><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>&emsp;&emsp;<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera机器学习 - Andrew Ng</a><br>&emsp;&emsp;<a href="http://cs229.stanford.edu/" target="_blank" rel="noopener">CS229 - Andrew Ng</a><br>&emsp;&emsp;<a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">《统计学习方法》- 李航</a><br>&emsp;&emsp;<a href="https://book.douban.com/subject/26708119/" target="_blank" rel="noopener">《机器学习》 - 周志华</a><br>&emsp;&emsp;<a href="https://cn.udacity.com/mlnd" target="_blank" rel="noopener">Udacity Machine Learning Engineer Nanodegree</a></p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>&emsp;&emsp;<a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera Deep Learning Sepecialization - deeplearning.ai</a></p><h4 id="自然语言系统"><a href="#自然语言系统" class="headerlink" title="自然语言系统"></a>自然语言系统</h4><p>&emsp;&emsp;(暂无)</p><h4 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h4><p>&emsp;&emsp;<a href="https://book.douban.com/subject/10769749/" target="_blank" rel="noopener">推荐系统实践 - 项亮</a></p><h4 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/" target="_blank" rel="noopener">Kaggle</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;微积分&quot;&gt;&lt;a href=&quot;#微积分&quot; class=&quot;headerlink&quot; title=&quot;微积分&quot;&gt;&lt;/a&gt;微积分&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://ocw.mit.edu/courses/mathematics/18-01sc-single-variable-calculus-fall-2010/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Single Variable Calculus - MIT&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;线性代数&quot;&gt;&lt;a href=&quot;#线性代数&quot; class=&quot;headerlink&quot; title=&quot;线性代数&quot;&gt;&lt;/a&gt;线性代数&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linear Algebra - MIT&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="deeplearning" scheme="http://yoursite.com/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习笔记-目录</title>
    <link href="http://yoursite.com/2018/09/03/machine_learning_note/"/>
    <id>http://yoursite.com/2018/09/03/machine_learning_note/</id>
    <published>2018-09-03T09:47:33.890Z</published>
    <updated>2018-09-07T16:05:14.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中……</p></blockquote><h5 id="Coursera机器学习笔记-一-监督学习vs无监督学习"><a href="#Coursera机器学习笔记-一-监督学习vs无监督学习" class="headerlink" title="Coursera机器学习笔记(一) - 监督学习vs无监督学习"></a><a href="https://bigmoutain.cn/2018/09/04/machine_learning_note_01/" target="_blank" rel="noopener">Coursera机器学习笔记(一) - 监督学习vs无监督学习</a></h5><h5 id="Coursera机器学习笔记-二-单变量线性回归"><a href="#Coursera机器学习笔记-二-单变量线性回归" class="headerlink" title="Coursera机器学习笔记(二) - 单变量线性回归"></a><a href="https://bigmoutain.cn/2018/09/04/machine_learning_note_02/" target="_blank" rel="noopener">Coursera机器学习笔记(二) - 单变量线性回归</a></h5><h5 id="Coursera机器学习笔记-三-多变量线性回归"><a href="#Coursera机器学习笔记-三-多变量线性回归" class="headerlink" title="Coursera机器学习笔记(三) - 多变量线性回归"></a><a href="https://bigmoutain.cn/2018/09/06/machine_learning_note_03/" target="_blank" rel="noopener">Coursera机器学习笔记(三) - 多变量线性回归</a></h5><h5 id="Coursera机器学习笔记-四-Octave教程"><a href="#Coursera机器学习笔记-四-Octave教程" class="headerlink" title="Coursera机器学习笔记(四) - Octave教程"></a><a href="https://bigmoutain.cn/2018/09/06/machine_learning_note_04/" target="_blank" rel="noopener">Coursera机器学习笔记(四) - Octave教程</a></h5><h5 id="Coursera机器学习笔记-五-Logistic-Regression"><a href="#Coursera机器学习笔记-五-Logistic-Regression" class="headerlink" title="Coursera机器学习笔记(五) - Logistic Regression"></a><a href="https://bigmoutain.cn/2018/09/07/machine_learning_note_05/" target="_blank" rel="noopener">Coursera机器学习笔记(五) - Logistic Regression</a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;持续更新中……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;Coursera机器学习笔记-一-监督学习vs无监督学习&quot;&gt;&lt;a href=&quot;#Coursera机器学习笔记-一-监督学习vs无监督学习&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
</feed>
