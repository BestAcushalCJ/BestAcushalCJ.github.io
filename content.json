{"meta":{"title":"大山","subtitle":"这是一个热爱技术、热爱烹饪的肥宅","description":"孤高锦瑟笑游侠","author":"大山","url":"http://yoursite.com"},"pages":[{"title":"archives","date":"2018-09-01T12:19:26.000Z","updated":"2018-09-01T12:20:05.974Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-01T12:18:15.000Z","updated":"2018-09-03T11:21:03.775Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-01T11:22:42.000Z","updated":"2018-09-01T11:24:46.112Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"论文写作常用结构记录","slug":"paper_writing_structure","date":"2019-04-22T14:32:33.117Z","updated":"2019-04-23T13:45:15.055Z","comments":true,"path":"paper_writing_structure/","link":"","permalink":"http://yoursite.com/paper_writing_structure/","excerpt":"","text":"1 Introduction1.1 研究背景、目的、意义1.2 避障的基本理论、通用算法这里讲一下研究现状，包括避障和自己使用的算法 1.2.1 国外研究现状1.2.2 国内研究现状1.3 本文的主要研究内容在这里把做过的事情要地描述一下 1.4 小结把上面讲过的点串一下（每一章的小结都一样） 2 避障方法2.1 原理这里主要是避障原理以及用到的算法所必须的先验知识（在下面公式推导中用的到的） 2.2 方法这里主要写只用DDPG来做避障的一个推导 2.3 我提出的方法这里主要写自己修改后的方法，由于做了两次修改，所以在这里分为两个小部分 2.3.1 fuzzy ART + DDPG2.3.2 在2.3.1的基础上加入好奇心机制2.4 小结####3 实验验证 3.1 实验设置在这里讲一下电脑配置参数、仿真环境设计（可以分点） 3.2 实验分别给出上述3个模型的训练（预测）结果，因为都是一边训练一边预测的 3.2.1 DDPG3.2.2 fuzzy ART + DDPG3.2.3 fuzzy ART + DDPG with curiosity3.3 对比分析、讨论3.4 小结4 结论4.1 总结4.2 尚且存在的问题、未来要做的工作（展望）","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"paper","slug":"paper","permalink":"http://yoursite.com/tags/paper/"}]},{"title":"Ubuntu16.04配置Gym、Torcs、Mujoco环境","slug":"RL_env_setup","date":"2019-04-22T11:11:25.339Z","updated":"2019-04-22T12:24:33.312Z","comments":true,"path":"RL_env_setup/","link":"","permalink":"http://yoursite.com/RL_env_setup/","excerpt":"","text":"1.安装Torcs1.1安装依赖项前提：python3.5.2安装xautomation包1sudo apt-get install xautomation 激活自己的anaconda环境（根据自己的环境来）1source activate RL 安装keras以及tensorflow（版本自己决定，我在使用的1.4）12pip install tensorflow==1.4pip install keras 安装numpy1pip insall numpy 1.2安装1.2.1 下载gym_torcs源码1git clone https://github.com/ugo-nama-kun/gym_torcs.git 1.2.2 将 gym_torcs/vtorcs-RL-color/src/modules/simu/simuv2/simu.cpp 中第64行替换为if (isnan((float)(car-&gt;ctrl-&gt;gear)) || isinf(((float)(car-&gt;ctrl-&gt;gear)))) car-&gt;ctrl-&gt;gear = 0;1.2.3 执行以下命执行安装命令1234567cd gym_torcs/cd vtorcs-RL-colorsudo apt-get install libglib2.0-dev libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev libplib-dev libopenal-dev libalut-dev libxi-dev libxmu-dev libxrender-dev libxrandr-dev libpng12-dev./configuremakesudo make installsudo make datainstall 1.3测试1.3.1 打开终端，输入：1torcs 1.3.2 若安装成功，会出现图形界面，然后依次点击Race –&gt; Practice –&gt; New Race –&gt; 会看到一个蓝屏输出信息“Initializing Driver scr_server1”。1.3.3 在终端中输入如下命令：123cd gym_torcssource activate RLpython snakeoil3_gym.py 1.3.4 若安装成功，可看到小车在马路上跑了，可以按F1，出现菜单选项，进行相应的观测。 2.安装Mujoco2.1 首先到官网下载mjpro150 linux2.2 接下来试用30天，或者学生免费使用一年，访问这里2.3 试用30天，填写信息，分别为姓名、邮件地址、电脑ID2.4 点击Linux，下载getid_linux文件2.5 进入getid_linux文件所在文件夹，输入如下命令：12chmod +x getid_linux./getid_linux 2.6 获得的Computer id填写到上面的文本框中。2.7 Mujoco会往你的注册邮箱发送一个mjkey.txt附件2.8 在home目录下创建隐藏文件夹mujoco，并将刚才下载好的mjpro150 linux安装包解压到这个文件夹下:1234mkdir ~/.mujococp mjpro150_linux.zip ~/.mujococd ~/.mujocounzip mjpro150_linux.zip 2.9 拷贝许可证12cp mjkey.txt ~/.mujococp mjkey.txt ~/.mujoco/mjpro150/bin 2.10 添加环境变量123gedit ~/.bashrcexport LD_LIBRARY_PATH=~/.mujoco/mjpro150/bin$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export MUJOCO_KEY_PATH=~/.mujoco$&#123;MUJOCO_KEY_PATH&#125; 2.11 测试Mujoco是否安装成功12cd ~/.mujoco/mjpro150/bin./simulate ../model/humanoid.xml 3.安装Mujoco-py3.1 安装依赖项1234sudo DEBIAN_FRONTEND=noninteractive apt-get install -y curl git libgl1-mesa-dev libgl1-mesa-glx libglew-dev libosmesa6-dev python3-pip python3-numpy python3-scipy net-tools unzip vim wget xpra xserver-xorg-devsudo apt-get cleanrm -rf /var/lib/apt/lists/*sudo apt-get update 3.2 安装patchelf12sudo curl -o /usr/local/bin/patchelf https://s3-us-west-2.amazonaws.com/openai-sci-artifacts/manual-builds/patchelf_0.9_amd64.elfsudo chmod +x /usr/local/bin/patchelf 3.3 下载mujoco-py1git clone https://github.com/openai/mujoco-py.git 3.4 安装mujoco-py12345678cd ~/mujoco-pycp requirements.txt requirements.dev.txt mujoco_pycd mujoco_pysource activate Gympip install -r requirements.txtpip install -r requirements.dev.txtpip install -U &apos;mujoco-py&lt;1.50.2,&gt;=1.50.1&apos;python setup.py install 3.5 测试安装是否成成功，在终端输入如下命令：123source activate RLpythonimport mujoco_py 若没有报错，则mojoco-py安装成功 安装gym(上述安装不报错，才可以成功进行这一步)1.1 在终端输入如下命令：12source activate RLpip install gym[all] 1.2 测试安装是否成功：12pythonimport gym","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/教程/"}],"tags":[{"name":"Ubuntu16","slug":"Ubuntu16","permalink":"http://yoursite.com/tags/Ubuntu16/"},{"name":"RL","slug":"RL","permalink":"http://yoursite.com/tags/RL/"}]},{"title":"Tensorflow模型的保存和加载","slug":"tensorflow_model_save_restore","date":"2019-04-04T06:58:07.178Z","updated":"2019-04-22T14:13:48.874Z","comments":true,"path":"tensorflow_model_save_restore/","link":"","permalink":"http://yoursite.com/tensorflow_model_save_restore/","excerpt":"","text":"1.Tensorflow的模型到底是什么样的？在训练好一个神经网络模型之后，我们通常希望将它保存下来，方便以后的使用。那么，什么是Tensorflow模型呢？Tensorflow模型主要包含网络图和训练好的各参数值等。所以，Tensorflow模型有两个主要的文件：1）Meta graph：这是一个协议缓冲区(protocol buffer)，它完整地保存了Tensorflow图；即所有的变量、操作、集合等。此文件以 .meta 为拓展名。2）checkpoint 文件集合：包含weights、biases、gradients 和其他所有变量的值。从Tensorflow 0.11版本之后，文件列表表示如下：12mymodel.data-00000-of-00001mymodel.index 3）checkpoint文件：用于保存最新checkpoint文件保存的记录 2.保存一个Tensorflow模型2.1 创建一个tf.train.Saver()类的实例1saver = tf.train.Saver() 2.2 Tensorflow变量仅存在于session内，所以必须在session内进行保存，可通过调用创建的saver对象的sava方法实现1saver.save(sess, &apos;mymodel&apos;) 其中sess是session对象，‘mymodel’是对模型的命名。一个完整的例子如下：1234567import tensorflow as tfw1 = tf.Variable(tf.random_normal(shape=[2]), name=&apos;w1&apos;)w2 = tf.Variable(tf.random_normal(shape=[5]), name=&apos;w2&apos;)saver = tf.train.Saver()sess = tf.Session()sess.run(tf.global_variables_initializer())saver.save(sess, &apos;my_test_model&apos;) 如果想在在迭代1000次后保存模型，我们需在对应的步数之后调用 sava 方法，一个简单的示例如下：12if step == 1000: saver.save(sess, &apos;mymodel&apos;, global_step=1000) 在训练过程中，如果想每迭代1000次就保存模型一次。在第一次保存模型时会创建 .meta 文件(第1000次迭代), 并且无需每次都重复创建（也就是无需在第2000、3000…或其他迭代时保存.meta文件）。因为图结构不变，仅需保存迭代后的参数值。因此，当我们不想写入meat-graph时，使用：1saver.save(sess, &apos;mymodel&apos;, global_step=step, write_meta_graph=False) 如果想保存最近的5个模型并且每训练2个小时保存一次，可以使用 max_to_keep 和 keep_checkpoint_every_n_hours参数，如下所示：1saver = tf.train.Saver(max_to_keep=4, keep_checkpoint_every_n_hours=2) 3.引入一个pretrained模型3.1 创建网络可以通过写python代码手工创建原来模型的网络。或者，通过之前保存的 .mate 文件进行网络创建，示例如下：1saver = tf.train.import_meta_graph(&apos;mymodel-1000.meta&apos;) import_meta_graph会将.meta文件中保存的网络加载到当前网络中，这会创建一个graph/network，但仍需加载已训练的各参数值。3.2 加载参数可以通过调用tf.train.Saver()类的restore方法来加载参数123with tf.Session() as sess: new_saver = tf.train.import_meta_graph(&apos;mymodel-1000.meta&apos;) new_saver.restore(sess, tf.train.latest_checkpoint(&apos;./&apos;)) 这样，像w1、w2这些tensors的值就加载进来了并且可以进行访问：1234with tf.Session() as sess: saver = tf.train.import_meta_graph(&apos;mymodel-1000.meta&apos;) saver.restore(sess,tf.train.latest_checkpoint(&apos;./&apos;)) print(sess.run(&apos;w1:0&apos;)) 4.如何使用加载后的模型下面是一个恢复预先训练过的模型，并将其用于预测、微调或进一步培训的示例。无论何时使用TensorFlow，都要定义一个图，表示输入示例（训练数据）和一些超参数（如学习率、全局步骤等）。使用占位符输入所有培训数据和超参数是一种标准实践。让我们用占位符构建一个小型网络并保存它。注意，保存网络时，不会保存占位符的值。1234567891011121314151617181920212223import tensorflow as tf#Prepare to feed input, i.e. feed_dict and placeholdersw1 = tf.placeholder(&quot;float&quot;, name=&quot;w1&quot;)w2 = tf.placeholder(&quot;float&quot;, name=&quot;w2&quot;)b1= tf.Variable(2.0,name=&quot;bias&quot;)feed_dict =&#123;w1:4,w2:8&#125;#Define a test operation that we will restorew3 = tf.add(w1,w2)w4 = tf.multiply(w3,b1,name=&quot;op_to_restore&quot;)sess = tf.Session()sess.run(tf.global_variables_initializer())#Create a saver object which will save all the variablessaver = tf.train.Saver()#Run the operation by feeding inputprint sess.run(w4,feed_dict)#Prints 24 which is sum of (w1+w2)*b1#Now, save the graphsaver.save(sess, &apos;mymodel&apos;,global_step=1000) 现在，当想要恢复它时，不仅要恢复图表和权重，还要准备一个新的feed-dict，它将把新的训练数据传送到网络。可通过graph.get_tensor_by_name()获得graph中对这些保存的操作和占位符变量的引用。12345#How to access saved variable/Tensor/placeholdersw1 = graph.get_tensor_by_name(&quot;w1:0&quot;)# How to access saved operationop_to_restore = graph.get_tensor_by_name(&quot;op_to_restore:0&quot;) 如果只想用不同的数据运行同一个网络，可以简单地通过feed-dict将新数据传递到网络：12345678910111213141516171819202122import tensorflow as tfsess=tf.Session() #First let&apos;s load meta graph and restore weightssaver = tf.train.import_meta_graph(&apos;mymodel-1000.meta&apos;)saver.restore(sess,tf.train.latest_checkpoint(&apos;./&apos;))# Now, let&apos;s access and create placeholders variables and# create feed-dict to feed new datagraph = tf.get_default_graph()w1 = graph.get_tensor_by_name(&quot;w1:0&quot;)w2 = graph.get_tensor_by_name(&quot;w2:0&quot;)feed_dict =&#123;w1:13.0,w2:17.0&#125;#Now, access the op that you want to run.op_to_restore = graph.get_tensor_by_name(&quot;op_to_restore:0&quot;)print sess.run(op_to_restore,feed_dict)#This will print 60 which is calculated#using new values of w1 and w2 and saved value of b1. 如果想通过添加更多的网络层来向图添加更多的操作，然后对其进行训练，一个简单的示例如下：1234567891011121314151617181920212223import tensorflow as tfsess=tf.Session() #First let&apos;s load meta graph and restore weightssaver = tf.train.import_meta_graph(&apos;mymodel-1000.meta&apos;)saver.restore(sess,tf.train.latest_checkpoint(&apos;./&apos;))# Now, let&apos;s access and create placeholders variables and# create feed-dict to feed new datagraph = tf.get_default_graph()w1 = graph.get_tensor_by_name(&quot;w1:0&quot;)w2 = graph.get_tensor_by_name(&quot;w2:0&quot;)feed_dict =&#123;w1:13.0,w2:17.0&#125;#Now, access the op that you want to run.op_to_restore = graph.get_tensor_by_name(&quot;op_to_restore:0&quot;)#Add more to the current graphadd_on_op = tf.multiply(op_to_restore,2)print sess.run(add_on_op,feed_dict)#This will print 120.","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/教程/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"Coursera机器学习笔记(八) - 神经网络(下)","slug":"machine_learning_note_08","date":"2018-10-19T06:27:46.890Z","updated":"2018-10-20T11:32:18.034Z","comments":true,"path":"machine_learning_note_08/","link":"","permalink":"http://yoursite.com/machine_learning_note_08/","excerpt":"","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Neural Networks:Learning课程Wiki：Neural Networks:Learning 代价函数在神经网络中我们使用L来表示总的层数, 例如下图中L=4; 使用$s_l$来表示在第$l$层unit的个数（不包括bias unit）,如下图中$s_1=3$,$s_2=5$,$s3=5$,$s_L=4$。对于一个分类问题要么是二分类(Binary classification)要么是多分类(Multi-class classification)。对于二分类问题, 神经网络只需要一个输出单元; 而对于多分类问题, 需要K个输出单元, 其中K为类的个数。这里我们按照多分类对代价函数进行描述. 下图为神经网络的代价函数与logistic回归的代价函数的对比。对于前半部分, 因为神经网络中有K个输出, 所以先要对这K个输出的损失求和; 对于后半部分, 因为每一层(除了输出层)都有一个$\\Theta$,所以正则化项要将这些权重都包括进来(当然, 不需要包括bias unit的权重)。如下图所示，$h_\\Theta(x)$是一个K维的向量, 即$h_\\Theta(x) \\in \\rm I!R^K$,我们用$(h_\\Theta(x))_i$来表示第i个输出值。下面这段文字是这个课程wiki对于神经网络代价函数的解释： the double sum simply adds up the logistic regression costs calculated for each cell in the output layer;the triple sum simply adds up the squares of all the individual Θs in the entire network;the i in the triple sum does not refer to training example i. 逆/反向传播算法知道了代价函数之后, 我们还是按照套路来求代价函数的最优解. 同样地, 我们希望使用梯度下降来找到最优解. 想要使用梯度下降当然需要求出”梯度”即偏导项$\\frac{\\partial}{\\partial\\Theta_{ij}^{(l)}}J(\\Theta)$。而计算这个偏导项的过程就叫做逆传播算法或者叫反向传播算法。首先我们根据前向传播算法来得到$a^{(1)}$,$a^{(2)}$,$a^{(3)}$,$a^{(4)}$和$z^{(1)}$,$z^{(2)}$,$z^{(3)}$。在逆传播算法中我们定义每层的误差$$\\delta^{(l)}=\\frac{\\partial}{\\partial z^{(l)}}J(\\Theta)$$$\\delta_j^{(l)}$表示第$l$层第$j$个节点的误差。为了求出偏导项$\\frac{\\partial}{\\partial\\Theta_{ij}^{(l)}}J(\\Theta)$，我们首先要求每一层的$\\delta$(不包括第一层, 因为第一层是输入层)。首先, 对于输出层即第4层(这里我们不考虑正则化):$$\\begin{align}\\delta_j^{(4)} &amp; = \\frac{\\partial}{\\partial z_i^{(4)}}J(\\Theta) \\ \\ &amp; = \\frac{\\partial J(\\Theta)}{\\partial a_i^{(4)}}\\frac{\\partial a_i^{(4)}}{\\partial z_i^{(4)}} \\ \\ &amp; = -\\frac{\\partial}{\\partial a_i^{(4)}}\\sum_{k=1}^K\\left[y_kloga_k^{(4)}+(1-y_k)log(1-a_k^{(4)})\\right]g’(z_i^{(4)}) \\ \\ &amp; = -\\frac{\\partial}{\\partial a_i^{(4)}}\\left[y_iloga_i^{(4)}+(1-y_i)log(1-a_i^{(4)})\\right]g(z_i^{(4)})(1-g(z_i^{(4)})) \\ \\ &amp; = \\left(\\frac{1-y_i}{1-a_i^{(4)}}-\\frac{y_i}{a_i^{(4)}}\\right)a_i^{(4)}(1-a_i^{(4)}) \\ \\ &amp; = (1-y_i)a_i^{(4)} - y_i(1-a_i^{(4)}) \\ \\ &amp; = a_i^{(4)} - y_i \\\\end{align}$$关于$g’(z_i^{(4)})$的证明见本文最后的补充材料。其中$a_j^{(4)}$就是$(h_\\Theta(x))_j$，$j$是输出单元的个数，用向量化的表示为：$\\delta^{(4)}=a^{(4)}-y$，对于剩下每层的$\\delta_i^{(l)}$如下：$$\\begin{align} \\delta_i^{(l)} &amp; = \\frac{\\partial}{\\partial z_i^{(l)}}J(\\Theta) \\ \\ &amp; = \\sum_{j=1}^{S_j}\\frac{\\partial J(\\Theta)}{\\partial z_j^{(l+1)}}\\cdot\\frac{\\partial z_j^{(l+1)}}{\\partial a_i^{(l)}}\\cdot\\frac{\\partial a_i^{(l)}}{\\partial z_i^{(l)}} \\ \\ &amp; = \\sum_{j=1}^{S_j}\\delta_j^{(l+1)}\\cdot\\Theta_{ij}^{(l)}\\cdot g’(z_i^{(l)}) \\ \\ &amp; = g’(z_i^{(l)})\\sum_{j=1}^{S_j}\\delta_j^{(l+1)}\\cdot\\Theta_{ij}^{(l)} \\end{align}$$写成向量的形式即为:$$\\delta^{(l)}=(\\Theta^{(l)})^T\\delta^{(l+1)}.*g’(z^{(l)})$$求出来所有的$\\delta$以后，可以很容易得到$\\frac{\\partial}{\\partial\\Theta_{ij}^{(l)}}J(\\Theta)=a_i^{(l)}\\delta_j^{(l+1)}$，这就是我们要求的偏导项(忽略正则化)。上面所有的推导都是基于一个样本的, 现在假设有$m$个样本, 我们可以使用BGD来求解最优值。假设我们有一个训练集如下图所示, 对于所有的$l,i,j$，我们先令$\\Delta_{ij}^{(l)}=0$，然后对于每一个样本, 都进行如下图所示的计算并使用$\\Delta_{ij}^{(l)}$进行累加。其中$\\Delta_{ij}^{(l)}:=\\Delta_{ij}^{(l)}+a_j^{(l)}\\delta_i^{(l+1)}$用向量的表示形式为:$\\Delta^{(l)}:=\\Delta^{(l)}+\\delta^{(l+1)}(a^{(l)})^T$，最后, 计算出$D_{ij}^{(l)}$如下图所示(注意,ppt上有个小错误, 我们的代价函数应该是$D_{ij}^{(l)}:=\\frac{1}{m}(\\Delta_{ij}^{(l)}+\\lambda\\Theta_{ij}^{(l)})$关于BP算法, 可以参考Caltech的Learning from Data 参数调整为了使用高级优化算法, 这一节我们讲如何调整参数. 在神经网络中, 参数$\\Theta^{(j)}$是一个矩阵, 而在之前利用高级优化算法的课程中, 我们知道$\\theta$是一个向量, 这个时候就需要对$\\Theta$进行Unrolling。如下图所示的神经网络中, (ppt中出现了一些错误, 根据$\\Theta_1$,$\\Theta_2$,$\\Theta_3$，这个神经网络应该是有4层, 并且$s_1=10$,$s_2=10$,$s_3=10$,$s_4=1$)。$\\Theta^{(1)}$,$\\Theta^{(2)}$,$\\Theta^{(3)}$,$D^{(1)}$,$D^{(2)}$,$D^{(3)}$,如下图所示, 在Octave/Matlab中, 我们可以使用如下代码将所有对应的矩阵转化成一个向量：123456thetaVec = [Theta1(:); Theta2(:); Theta3(:)];DVec = [D1(:); D2(:); D3(:)]%使用如下代码可以得到原来的矩阵Theta1 = reshape(thetaVec(1: 110), 10, 11);Theta2 = reshape(thetaVec(111: 220), 10, 11);Theta3 = reshape(thetaVec(221: 231), 1, 11); 下图为利用unrolling来使用高级优化算法的步骤： 梯度检查由于神经网络的复杂性, 我们在使用梯度下降或者其他的高级优化算法时可能会出现bug, 即使感觉上好像没什么问题。那么如何能有效地检查出问题呢, 这个时候就需要使用Gradient Checking。首先, 如下图所示, 我们使用如下近似：$\\frac{d}{d\\theta}J(\\theta)\\approx \\frac{J(\\theta+\\epsilon)-J(\\theta-\\epsilon)}{2\\epsilon}$，通常我们取$\\epsilon=10^{-4}$。上面的例子中$\\theta$是一个实数, 在下图中, $\\theta$是一个向量, 此时是对偏导数进行数值估计。在实际运用中, 我们使用如下代码来计算gradApprox。然后, 我们将通过逆传播算法计算得来的DVec和gradApprox进行比较, 如果这两个值近似的话, 那么就说明我们的逆传播算法运行地没有问题。下图描述了使用Gradient Checking时的步骤。需要主意的是, 在得到gradApprox之后一定要即时关闭Gradient Checking, 因为它会非常大地消耗计算资源。 随机初始化在之前的linear regression和logistic regression中我们初始化$\\theta$的值为0。在神经网络中也可以这么初始化吗?现初始化$\\Theta_{ij}^{(l)}=0$，此时会有$a_1^{(2)}=a_2^{(2)}$,$\\delta_1^{(2)}=\\delta_2^{(2)}$。这样不论进行多少次更新, 永远会有$a_1^{(2)}=a_2^{(2)}$，也就是说这两个神经元是完全等同的, 这显然不合理, 那么我们应该如何初始化参数呢?对于$\\Theta^{(1)} \\in \\mathbb{R}^{10\\times 11}$，使用随机函数来进行初始化：1Theta1 = rand(10, 11)*(2*INIT_EPSILON) - INIT_EPSILON 模型选择神经网络有许许多多种结构, 我们应该如何选择神经网络的结构？在神经网络中, 有两个是确定的, 那就是输入单元的个数和输出单元的个数。因为前者就是特征的个数（维度）, 而后者是分类的数量。一个合理的默认值为, 有一个隐藏层；或者有多个隐藏层, 并且这些隐藏层单元数量相等。 总结 补充材料$$\\begin{align} \\frac{\\partial g(z)}{\\partial z} &amp; = -\\left( \\frac{1}{1 + e^{-z}} \\right)^2\\frac{\\partial{}}{\\partial{z}} \\left(1 + e^{-z} \\right) \\ \\ &amp; = -\\left( \\frac{1}{1 + e^{-z}} \\right)^2e^{-z}\\left(-1\\right) \\ \\ &amp; = \\left( \\frac{1}{1 + e^{-z}} \\right) \\left( \\frac{1}{1 + e^{-z}} \\right)\\left(e^{-z}\\right) \\ \\ &amp; = \\left( \\frac{1}{1 + e^{-z}} \\right) \\left( \\frac{e^{-z}}{1 + e^{-z}} \\right) \\ \\ &amp; = \\left( \\frac{1}{1+e^{-z}}\\right)\\left( \\frac{1+e^{-z}}{1+e^{-z}}-\\frac{1}{1+e^{-z}}\\right) \\ \\ &amp; = g(z) \\left( 1 - g(z)\\right) \\ \\ \\end{align}$$","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/tags/Machine-Learning/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"},{"name":"Note","slug":"Note","permalink":"http://yoursite.com/tags/Note/"},{"name":"Neural Network","slug":"Neural-Network","permalink":"http://yoursite.com/tags/Neural-Network/"}]},{"title":"Coursera机器学习笔记(七) - 神经网络(上)","slug":"machine_learning_note_07","date":"2018-09-24T06:24:20.581Z","updated":"2018-10-17T16:41:50.626Z","comments":true,"path":"machine_learning_note_07/","link":"","permalink":"http://yoursite.com/machine_learning_note_07/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Neural Networks:Representation课程Wiki：Neural Networks:Representation 为什么要使用神经网络对于下图所示的分类问题, 我们可以利用高阶项来构造我们的假设函数. 但是, 实际问题往往有很多特征. 例如在房价预测的问题中, 我们可能有100个特征, 如果想要多项式包含所有的二次项那么这个多项式会有5,000个特征(复杂度为$O(n^2)$)。这样就会带来两个问题：1.过拟合 2.消耗大量计算资源. 当然可以使用所有二次项的子集, 例如$x_1^2, x_2^2, x_3^2, …$，但是这样可能又欠拟合. 如果想要包含所有的三次项, 那大概会有170,000个特征, 复杂度为$O(n^3)$。","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Neural Networks:Representation课程Wiki：Neural Networks:Representation 为什么要使用神经网络对于下图所示的分类问题, 我们可以利用高阶项来构造我们的假设函数. 但是, 实际问题往往有很多特征. 例如在房价预测的问题中, 我们可能有100个特征, 如果想要多项式包含所有的二次项那么这个多项式会有5,000个特征(复杂度为$O(n^2)$)。这样就会带来两个问题：1.过拟合 2.消耗大量计算资源. 当然可以使用所有二次项的子集, 例如$x_1^2, x_2^2, x_3^2, …$，但是这样可能又欠拟合. 如果想要包含所有的三次项, 那大概会有170,000个特征, 复杂度为$O(n^3)$。 下面考虑一个计算机视觉的问题. 假设我们想训练一个可以识别汽车图片的分类器. 一张图片对于计算机来说就是一堆数字矩阵。对于一个50x50的图像会有2,500个像素, 即n=2,500(如果是RGB图的话n就是7500). 如果我们想要包含所有的二次项, 那么特征就是3,000,000个。对于这类问题使用logistic回归显然是没法解决的, 这个时候就要用到神经网络(Neural Network)。 神经网络结构下图为一个神经元(neuron), 它的输入为$x_1, x_2, x_3$，有时候为了方便我们添加一个$x_0$，叫做bias unit. 它的输出为$h(\\theta)$，$\\theta$也叫做weights。下图为由多个神经元组成的神经网络. 第一层叫做输入层(input layer), 最后一层叫做输出层(output layer), 中间的叫做隐藏层(hidden layer)。注意: 如果在第$j$层有$s_j$个units，在第$j+1$层有$s_{j+1}$个units，那么$\\Theta^{(j)}$就是一个$s_{(j+1)} \\times (s_j + 1)$的矩阵。(因为前一层增加了一个bias unit) 前向传播算法前向传播算法其实就是由输入层计算出输出的过程, 这里为了提高计算的效率, 我们使用向量化的算法. 首先我们做如下定义:$$z_1^{(2)}=\\Theta_{10}^{(1)}x_0+\\Theta_{11}^{(1)}x_1+\\Theta_{12}^{(1)}x_2+\\Theta_{13}^{(1)}x_3$$$$z_2^{(2)}=\\Theta_{20}^{(1)}x_0+\\Theta_{21}^{(1)}x_1+\\Theta_{22}^{(1)}x_2+\\Theta_{23}^{(1)}x_3$$$$z_3^{(2)}=\\Theta_{30}^{(1)}x_0+\\Theta_{31}^{(1)}x_1+\\Theta_{32}^{(1)}x_2+\\Theta_{33}^{(1)}x_3$$$$z^{(2)} =\\begin{bmatrix} z_1^{(2)} \\ z_2^{(2)} \\ z_3^{(2)} \\end{bmatrix}$$这样$z^{(2)}$的计算就可以写成向量计算:$z^{(2)} = \\Theta^{(1)}x$，进而有$a^{(2)}=g(z^{(2)})$，为了和后面几层的写法统一, 我们令$a^{(1)}=x$，所以有$z^{(2)} = \\Theta^{(1)}a^{(1)}$。我们在隐藏层加上一个额外的$a_{(0)}^{(2)}=1$，得到$a^{(2)}=\\begin{bmatrix} a_0^{(2)} \\ a_1^{(2)} \\ a_2^{(2)} \\ a_3^{(2)} \\end{bmatrix}$，同理，$z^{(3)}=\\Theta^{(2)}a^{(2)}$，最后$h_\\Theta(x)=a^{(3)}=g(z^{(3)})$。现在我们先把刚才的神经网络的输入层遮住, 观察剩下部分的结构以及算法我们发现, 其实这一部分其实就是前面所讲的logistic回归. 不同的是, 它的输入$\\alpha$是由真正的特征$x$学习得到的，可以把$\\alpha$看出新的特征，$x$看成初始特征。这样, 神经网络就相当于通过初始特征学习到新的特征, 再通过新的特征进行logistic回归得到输出结果。当然, 神经网络不仅仅是上面一种结构, 下图展示了另一种神经网结构 神经网络与逻辑运算逻辑与 逻辑或逻辑与运算, 参数为-30, 20, 20. 结果如下图所示：逻辑或运算, 参数为-10, 20, 20. 结果如下图所示： 逻辑非逻辑非运算, 参数为10, -20. 结果如下图所示：将三个神经单元组成一个神经网络, 可以得到同或运算： 多分类下两图为多分类问题：","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/tags/Machine-Learning/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"},{"name":"Note","slug":"Note","permalink":"http://yoursite.com/tags/Note/"},{"name":"Neural Network","slug":"Neural-Network","permalink":"http://yoursite.com/tags/Neural-Network/"}]},{"title":"人工智能、机器学习和深度学习","slug":"AI_ML_DL_comments","date":"2018-09-16T08:09:26.966Z","updated":"2018-09-16T08:11:50.589Z","comments":true,"path":"AI_ML_DL_comments/","link":"","permalink":"http://yoursite.com/AI_ML_DL_comments/","excerpt":"人工智能、机器学习和深度学习 机器学习需要解决的问题：如何让计算机可以和人类一样从历史的经验中获取新的知识？ 提取特征：如何数字化地表达现实世界中的实体。如何从实体中提取特征，对于机器学习算法的性能有很大影响。例：如果将图书馆中的图书信息存储为结构化的数据，如存在excel表中，那么非常容易通过书名等信息查找一本书是否在图书馆中；如果图书信息存储在非结构化的图片中，那么完成查找任务就会变得十分困难。","text":"人工智能、机器学习和深度学习 机器学习需要解决的问题：如何让计算机可以和人类一样从历史的经验中获取新的知识？ 提取特征：如何数字化地表达现实世界中的实体。如何从实体中提取特征，对于机器学习算法的性能有很大影响。例：如果将图书馆中的图书信息存储为结构化的数据，如存在excel表中，那么非常容易通过书名等信息查找一本书是否在图书馆中；如果图书信息存储在非结构化的图片中，那么完成查找任务就会变得十分困难。同样的数据使用不同的表达方式会极大的影响解决问题的难度。例：在笛卡尔坐标系中表示为类似一个圆形的两种颜色点数据集合，不同颜色的点无法被一条直线划分，但是如果将这些点映射到极角坐标系中，那么使用直线划分就很容易。一旦解决了特征提取和数据表达，很多人工智能任务也就解决了大半。 人工的方式无法很好的抽取实体中的特征，深度学习的核心问题之一就是自动地将简单的特征组合成更加复杂的特征，并使用这些组合特征解决问题。 深度学习时机器学习的一个分支。 传统机器学习算法：输入–&gt;人工特征提取–&gt;权重学习–&gt;预测结果深度学习算法：输入–&gt;基础特征提取–&gt;多次复杂特征提取–&gt;权重学习–&gt;预测结果","categories":[{"name":"随想","slug":"随想","permalink":"http://yoursite.com/categories/随想/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"Coursera机器学习笔记(六) - 正则化","slug":"machine_learning_note_06","date":"2018-09-08T06:53:34.556Z","updated":"2018-10-15T07:32:56.397Z","comments":true,"path":"machine_learning_note_06/","link":"","permalink":"http://yoursite.com/machine_learning_note_06/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Regularization课程Wiki：Regularization 过拟合如下图所示, 使用三种不同的多项式作为假设函数对数据进行拟合, 左一和右一分别为过拟合和欠拟合。","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Regularization课程Wiki：Regularization 过拟合如下图所示, 使用三种不同的多项式作为假设函数对数据进行拟合, 左一和右一分别为过拟合和欠拟合。 对率回归:解决过拟合问题大致分为两种, 一种是减少特征的数量, 可以人工选择一些比较重要的特征留下, 也可以使用模型选择算法(Model selection algorithm,后面的课程会介绍)；另一种就是正则化(Regularization)。 正则化如图所示的两个假设函数, 其中第二个为过拟合. 那么该如何改变代价函数能够让最中的假设函数不过拟合? 对比两个假设函数我们可以看到, 它们的区别就在于第二个多了两个高阶项. 也就是说, 我们不希望出现后面两个高阶项, 即希望$\\theta_3$、$\\theta_4$尽可能小。通过上面的想法, 我们把$\\theta_3$、$\\theta_4$放到代价函数中，并且加上很大的权重(1000):$$J(\\theta)=\\frac{1}{2m}\\sum_{i=1}^m(h_\\theta(x^{(i)})-y^{(i)} )^2+1000\\theta_3^2+1000\\theta_4^2$$现在如果要最小化代价函数, 那么最后两项也必须得最小. 这个时候, 就有$\\theta_3\\approx0$，$\\theta_4\\approx0$，从而这个四次多项式就变成了一个二次多项式, 解决了过拟合的问题。对于正则化的一般思路是, 减少特征的数量, 降低模型的复杂度. 所以我们要对每个参数进行惩罚, 从而得到’更简单’的并且可以防止过拟合的模型. 但是在实际问题中我们很难判断哪些特征比较重要, 所以对每一个参数(除了第一个)参数进行惩罚, 将代价函数改为:$$J(\\theta)=\\frac{1}{2m}\\left[\\sum_{i=1}^m(h_\\theta(x^{(i)})-y^{(i)} )^2+\\lambda\\sum_{i=1}^n\\theta_i^2\\right]$$其中，$\\lambda\\sum_{i=1}^n\\theta_j^2$叫做正则化项(Regularization Term)，$\\lambda$叫做正则化参数(Regularization Parameter)。$\\lambda$的作用就是在”更好地拟合数据”和”防止过拟合”之间权衡。如果$\\lambda$过大的话，就会导致$\\theta_1$、$\\theta_2$、$\\theta_3$…近似于0, 这样我们的假设函数就为：$h_\\theta(x)=\\theta_0$。这时就变成了欠拟合(Underfit). 所以需要选择一个合适的$\\lambda$。后面的课程会讲到自动选择合适的$\\lambda$的方法。 正则化线性回归通过正则化之后的$J(\\theta)$我们可以得到对应的梯度下降算法, 如下图所示. 因为我们不对$\\theta_0$进行惩罚, 所以将$\\theta_0$的规则单独写出来, 其余的参数更新规则如下图第三行公式. 公式前半部分$1-\\alpha\\frac{\\lambda}{m}$是一个比1小一点点的数(教授举了个例子大概是0.99), 而公式的后半部分和没有进行正则化的梯度下降的公式的后半部分是完全一样的. 所以区别就在于前半部分会将$\\theta_j$缩小(因为乘了一个小于1的数)。同样, 在正规方程中, 我们只需要在公式中加上一部分如下图所示并且对于正则化后的正规方程, 只要$\\lambda&gt;0$, 括号里的那一项总是可逆的: 正则化对率回归类似地, 正则化逻辑回归中的代价函数和梯度下降如下图所示下图是使用正则化的高级优化算法, 只需要在计算jVal时在后面加上一个正则化项以及在梯度后面减去一个$\\frac{\\lambda}{m}\\theta_j$","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/tags/Machine-Learning/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"},{"name":"Note","slug":"Note","permalink":"http://yoursite.com/tags/Note/"},{"name":"Regularization","slug":"Regularization","permalink":"http://yoursite.com/tags/Regularization/"}]},{"title":"Coursera机器学习笔记(五) - Logistic Regression","slug":"machine_learning_note_05","date":"2018-09-07T15:59:57.178Z","updated":"2018-10-14T15:41:55.675Z","comments":true,"path":"machine_learning_note_05/","link":"","permalink":"http://yoursite.com/machine_learning_note_05/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Logistic Regression课程Wiki：Logistic Regression 模型展示从线性回归解到对数几率回归前面的课程中提到了一些分类问题:","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Logistic Regression课程Wiki：Logistic Regression 模型展示从线性回归解到对数几率回归前面的课程中提到了一些分类问题: 对于乳腺癌的那个例子, 数据集如下所示. 如果使用线性回归来处理这个问题, 我们可能得到这样一个假设函数:然后我们设定一个阈值0.5, 当假设函数的输出大于这个阈值时我们预测$y=1$；当假设函数的输出小于0.5时, 我们预测$y=0$。即使我们的问题是一个分类问题, 但是对于上面这个特定的例子, 看上去使用线性回归好像还是挺合理的. 但是如果我们再增加一个数据(下图最右), 使用Linear Regression就会得到如图蓝色线所示的$h_\\theta(x)$。这个结果显然是不合理的, 它有很多错误的分类。 直观上来看, 要是能得到图中垂直于横轴的(图中蓝色)线那便是极好的。而且即使所有的训练样例的$y = 0或1$, 使用线性回归得到的$h_\\theta(x)$也有可能大于1或者小于0。所以我们需要一个能更好地处理分类问题的模型, 即对数几率回归(Logistic Regression/Logit regression). (有些地方翻译成“逻辑回归”或者“逻辑斯蒂格回归”) 需要注意的是这个模型虽然叫regression, 但是它是一个用来解决分类问题的模型。在对率回归(对数几率回归的简称)中,$0\\le h_\\theta(x)\\le1$。 假设函数在对率回归中, 假设函数为$h_\\theta(x)=g(\\theta^Tx)$，其中$g(z)=\\frac{1}{1+e^{-z}}$，$g(z)$叫做Sigmoid Function或者对率函数(Logistic Function)。对数几率函数是Sigmoid函数的一种, 它将z值转化为一个接近0或1的y值, 并且其输出值在$z=0$附近变化很陡. Sigmoid函数即形似S的函数, 对率函数是Sigmoid函数最重要的代表。$${h_\\theta(x)=\\frac{1}{1+e^{-\\theta^Tx}}}$$我们可以将对率函数的输出理解为当输入为x的时候, y=1的概率. 可以用$h_\\theta(x)=P(y=1|x;\\theta)$表达. 例如, 在下图中, 我们给定一个x, 它的假设函数的输出为0.7, 我们可以说这个病人的肿瘤为恶性的概率是70%。 决策边界如图所示的Sigmoid函数, 我们可以看到, 当$z&gt;0$的时候$g(z)\\ge0.5$即预测$y=1$；当$z&lt;0$的时候$g(z)&lt;0.5$即预测$y=0$。而在对率回归中, 我们的$z=\\theta^Tx$，所以我们有：当$\\theta^Tx&gt;0$时，预测$y=1$；当$\\theta^Tx&lt;0$时，预测$y=0$。如下图所示下面举一个例子看一看什么是决策边界. 如下图所示, 左边为数据集. 假设此时我们已经通过训练得到了$\\theta=\\begin{bmatrix}-3\\ 1\\ 1\\end{bmatrix}$，由上图可知, 当$\\theta^Tx&gt;0$时，预测$y=1$，即当$-3+x_1+x_2\\ge0$时, 预测$y=1$；也即当$x_1+x_2\\ge3$时, 预测$y=1$。我们在坐标中画出$x_1+x_2=3$的图形, 如果数据在这条直线的上方, 我们就预测$y=1$；如果数据在这条直线的下方, 我们就预测$y=0$，我们把$x_1+x_2\\ge3$称为决策边界(Decision Boundary)。下面看一个比较复杂的决策边界的例子。在线性回归的时候谈到过使用高阶多项式特征, 当然这里我们也可以用。我们添加两个特征一个是$x_1^2$，一个是$x_2^2$，假设我们通过训练得到参数$\\theta$，如下图所示。当$-1+x_1^2+x_2^2\\ge0$的时候, 预测$y=1$，即$x_1^2+x_2^2\\ge1$的时候, 预测$y=1$，画出$x_1^2+x_2^2=1$的图形，在圆内$y=0$，在园外$y=1$。这是一个圆形的决策边界。当我们有更高阶的多项式时, 我们会得到更加复杂的决策边界。 代价函数在之前的线性回归中, 我们的代价函数为：$${J(\\theta)=\\frac{1}{m}\\sum_{i=1}^m\\frac{1}{2}\\left(h_\\theta(x^{(i)})-y^{(i)}\\right)^2}$$令$$Cost\\left(h_\\theta(x^{(i)}),y^{(i)}\\right)=\\frac{1}{2}\\left(h_\\theta(x^{(i)})-y^{(i)}\\right)^2$$简记为$$Cost\\left(h_\\theta(x),y\\right)=\\frac{1}{2}\\left(h_\\theta(x)-y\\right)^2$$在线性回归中, 之所以可以使用梯度下降来找到全局最优解是因为代价函数$J(\\theta)$是一个凸函数(convex). 但是对于对率回归来说, 假设函数$h_\\theta(x)=\\frac{1}{1+e^{-\\theta^Tx}}$是一个较为复杂的非线性函数, 直接带入的话得到的代价函数就不是一个凸函数(non-convex), 如下图左侧部分所示. 这样使用梯度下降只能找到局部最优. 所以现在我们需要构造一个合理的并且是凸函数的代价函数。在对数几率回归中, 使用如下的$Cost\\left(h_\\theta(x),y\\right)$当$y=1$时，$Cost\\left(h_\\theta(x),y\\right)$如下图所示，此时, 如果我们$h_\\theta(x)=1$，那么$Cost=0$，即当预测结果和真实结果一样时, 我们不对学习算法进行惩罚；但是当结果不一致时, 即$h_\\theta(x)→ 0$时, 我们对算法的惩罚趋近于无穷。同样地, 下图是当$y=0$时的情况这样对代价函数处理之后, 我们的代价函数就是一个凸函数, 可以使用梯度下降来站到一个全局最优解。 梯度下降因为y的值只有0或1两种情况, 我们现在将$Cost\\left(h_\\theta(x),y\\right)$用一个式子来表达:$${Cost\\left(h_\\theta(x),y\\right)=-ylog(h_\\theta(x))-(1-y)log(1-h_\\theta(x))}$$(可以带入验证)于是得到代价函数:$${J(\\theta)=-\\frac{1}{m}\\left[\\sum_{i=1}^my^{(i)}log(h_\\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\\theta(x^{(i)}))\\right]}$$到这里, 后面的步骤就和线性回归很相似了. 直接利用梯度下降即可. 同样地我们需要求偏导, 求完偏导之后我们发现得到的更新规则和之前线性回归的更性规则是一模一样的. 除了假设函数$h_\\theta(x)$一样. 这里如果特征之间的数量级差别较大也是需要特征缩放的. (注:下图公式中$\\alpha$后少了一个$1/m$) 高级优化算法除了梯度下降还有其他更加高级更加复杂的算法：Conjugate Gradient、BFGS和L-BFGS. 如下图, 右下角是这些算法的优点和缺点。下图是一个具体的例子, 右边是自己定义的代价函数, 下方的options是调用fminunc所需的参数, initialTheta是初始的$\\theta$，然后调用fminunc并传入相应的参数就可以得到最优的$\\theta$。代价函数的代码如下:12345function [jVal, gradient] = costFunction(theta)jVal = (theta(1)-5)^2 + (theta(2)-5)^2;gradient = zeros(2,1);gradient(1) = 2*(theta(1)-5);gradient(2) = 2*(theta(2)-5); 在Octave中演示如下: 多分类问题下图举了一些多分类(Multiclass Classification)的例子在之前的二分类(Binary Classification)的问题中, 我们的数据集大概是如下图左侧所示. 而现在的多分类(Multi-class Classification)的问题中数据集如下图左侧所示:我们可以使用一对多(One-vs-all/One-vs-rest)方法来处理这个问题, 即将其分成三个二分类的问题. 如下图所示:预测时, 需要计算出$h_\\theta^{(1)}(x)$、$h_\\theta^{(2)}(x)$、$h_\\theta^{(3)}(x)$的值并得出最大值, 其对应的分类即为预测$x$的分类。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"},{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"},{"name":"Octave","slug":"Octave","permalink":"http://yoursite.com/tags/Octave/"}]},{"title":"Coursera机器学习笔记(四) - Octave教程","slug":"machine_learning_note_04","date":"2018-09-06T15:38:08.933Z","updated":"2018-10-13T03:36:36.647Z","comments":true,"path":"machine_learning_note_04/","link":"","permalink":"http://yoursite.com/machine_learning_note_04/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Octave Tutorial课程Wiki：Octave Tutorial参考：Octave documentation pages&emsp;&emsp;Introduction to Octave 基本操作四则运算12345678octave:1&gt; 5+6ans = 11octave:2&gt; 3-2ans = 1octave:3&gt; 5*8ans = 40octave:4&gt; 1/2ans = 0.50000","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Octave Tutorial课程Wiki：Octave Tutorial参考：Octave documentation pages&emsp;&emsp;Introduction to Octave 基本操作四则运算12345678octave:1&gt; 5+6ans = 11octave:2&gt; 3-2ans = 1octave:3&gt; 5*8ans = 40octave:4&gt; 1/2ans = 0.50000 逻辑运算12345678910octave:6&gt; 1 == 2ans = 0octave:7&gt; 1 ~= 2ans = 1octave:8&gt; 1 &amp;&amp; 0ans = 0octave:9&gt; 1 || 0ans = 1octave:10&gt; xor(1,0)ans = 1 其他更改提示符：12octave:11&gt; PS1(&apos;&gt;&gt; &apos;)&gt;&gt; 添加分号可抑制输出：1234&gt;&gt; a = 1a = 1&gt;&gt; a = 1;&gt;&gt; 圆周率$\\pi$：12&gt;&gt; a = pia = 3.1416 常数$e$：12&gt;&gt; eans = 2.7183 格式化输出：12345678910&gt;&gt; disp(sprintf(&apos;6 decimals: %0.6f&apos;, a))6 decimals: 3.141593&gt;&gt; disp(sprintf(&apos;6 decimals: %0.2f&apos;, a))6 decimals: 3.14&gt;&gt; format long&gt;&gt; aa = 3.14159265358979&gt;&gt; format short&gt;&gt; aa = 3.1416 矩阵构造一个矩阵，方式一：123456&gt;&gt; A = [1 2; 3 4; 5 6;]A = 1 2 3 4 5 6 构造一个矩阵，方式二：123456789&gt;&gt; A = [1 2;&gt; 3 4;&gt; 5 6;&gt; ]A = 1 2 3 4 5 6 构造一个横向量：1234&gt;&gt; v = [1 2 3]v = 1 2 3 构造一个列向量：123456&gt;&gt; v = [1; 2; 3]v = 1 2 3 从1到2，每次递增0.1：1234567891011121314&gt;&gt; v = 1:0.1:2v = Columns 1 through 5: 1.0000 1.1000 1.2000 1.3000 1.4000 Columns 6 through 10: 1.5000 1.6000 1.7000 1.8000 1.9000 Column 11: 2.0000 从1到6，每次递增1(默认)：1234&gt;&gt; v = 1:6v = 1 2 3 4 5 6 所有元素均为1：12345&gt;&gt; ones(2, 3)ans = 1 1 1 1 1 1 每个元素乘以2：12345&gt;&gt; C = 2*ones(2, 3)C = 2 2 2 2 2 2 高斯随机数：123456&gt;&gt; rand(3, 3)ans = 0.751588 0.906707 0.081204 0.411613 0.457779 0.882052 0.622524 0.774499 0.811092 所有元素均为0：1234&gt;&gt; w = zeros(1, 3)w = 0 0 0 单位矩阵：12345678910&gt;&gt; I = eye(5)I =Diagonal Matrix 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 读取矩阵A第三行第二列的元素：1234567A = 1 2 3 4 5 6&gt;&gt; A(3, 2)ans = 6 读取矩阵A第2列所有元素：123456&gt;&gt; A(:,2)ans = 2 4 6 读取矩阵A第2行所有元素：1234&gt;&gt; A(2,:)ans = 3 4 读取矩阵A第1行和第3行的所有元素：12345&gt;&gt; A([1 3],:)ans = 1 2 5 6 将A第二列替换为[10;11;12]：123456&gt;&gt; A(:,2) = [10; 11; 12]A = 1 10 3 11 5 12 在A的最后加上一列：123456&gt;&gt; A = [A, [100; 101; 102]]A = 1 10 100 3 11 101 5 12 102 将A所有的元素合并成一个列向量:123456789101112&gt;&gt; A(:)ans = 1 3 5 10 11 12 100 101 102 两个矩阵的合并（列合并）:1234567891011121314151617181920&gt;&gt; A = [1 2; 3 4; 5 6]A = 1 2 3 4 5 6&gt;&gt; B = [7 8; 9 10; 11 12]B = 7 8 9 10 11 12&gt;&gt; C = [A B]C = 1 2 7 8 3 4 9 10 5 6 11 12 两个矩阵的合并（行合并）:123456789&gt;&gt; D = [A;B]D = 1 2 3 4 5 6 7 8 9 10 11 12 杂项构造10000个随机数，并绘制出图形(高斯分布)：12&gt;&gt; w=randn(1,10000);&gt;&gt; hist(w,50) 数据的读取和存储 本节所用到的数据: featuresX.dat, priceY.dat 读取数据12345% 找到文件所在目录：&gt;&gt; cd Desktop/&gt;&gt; cd &apos;Machine Learning/&apos;&gt;&gt; lsfeaturesX.dat priceY.dat 123456% 方式一：&gt;&gt; load featuresX.dat&gt;&gt; load priceY.dat% 方式二：&gt;&gt; load(&apos;featuresX.dat&apos;)&gt;&gt; load(&apos;priceY.dat&apos;) 使用who命令显示当前所有变量：123456&gt;&gt; whoVariables in the current scope:A a featuresX v yC ans priceY wI c sz x 可以看到，刚才导入的数据已经在变量featuresX和priceY中了。展示数据：1234567891011121314151617181920212223242526272829303132&gt;&gt; featuresXfeaturesX = 2104 3 1600 3 2400 3 1416 2 3000 4 1985 4 1534 3 ... ..&gt;&gt; size(featuresX)ans = 27 2&gt;&gt; priceYpriceY = 3999 3299 3690 2320 5399 2999 ...&gt;&gt; size(priceY)ans = 27 1 使用如下命令用来删除某个变量：12&gt;&gt; clear featuresX&gt;&gt; whos 存储数据假设我们现在需要取出priceY前十个数据，使用如下命令：12345678910111213&gt;&gt; v = priceY(1:10)v = 3999 3299 3690 2320 5399 2999 3149 1989 2120 2425 该如何存储这十个数据呢？使用save命令：123&gt;&gt; save hello.mat v&gt;&gt; lsfeaturesX.dat hello.mat priceY.dat 清空所有变量：123&gt;&gt; clear&gt;&gt; whos&gt;&gt; %无任何输出 刚才存储数据是以二进制的形式进行存储，我们也可以使用人能够读懂的形式存储。例如：123456789101112131415161718192021222324252627&gt;&gt; load hello.mat&gt;&gt; whosVariables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== v 10x1 80 doubleTotal is 10 elements using 80 bytes&gt;&gt; vv = 3999 3299 3690 2320 5399 2999 3149 1989 2120 2425&gt;&gt; save hello.txt v -ascii&gt;&gt; lsfeaturesX.dat hello.mat hello.txt priceY.dat 数据计算12345678% 各种矩阵运算&gt;&gt; A * B&gt;&gt; A .* B&gt;&gt; A .^ 2&gt;&gt; 1 ./ A&gt;&gt; log(A)&gt;&gt; exp(A)&gt;&gt; -A A中的每个元素都加上1：1&gt;&gt; A + ones(size(A)) 这样也可以：1&gt;&gt; A + 1 矩阵转置：1&gt;&gt; A&apos; 向量中的最大值：12345678&gt;&gt; A = [1 3 0.5 10 100]A = 1.00000 3.00000 0.50000 10.00000 100.00000&gt;&gt; [val ind] = max(A)val = 100ind = 5 比较大小：12345678910111213&gt;&gt; A = [1 2; 3 4; 5 6]A = 1 2 3 4 5 6&gt;&gt; A &gt; 3ans = 0 0 0 1 1 1 找出向量中特定元素：123456&gt;&gt; find(A &gt; 3)ans = 3 5 6 找出矩阵中特定元素：1234567891011121314&gt;&gt; [r c] = find(A &gt;= 3)r = 2 3 2 3c = 1 1 2 2 生成任意行、列、对角线和相等的矩阵：123456&gt;&gt; magic(3)ans = 8 1 6 3 5 7 4 9 2 向量所有元素的和：1234567&gt;&gt; a = [1.2 2.3 4.5 6.6]a = 1.2000 2.3000 4.5000 6.6000&gt;&gt; sum(a)ans = 14.600 向上及向下取整：123456789&gt;&gt; floor(a)ans = 1 2 4 6&gt;&gt; ceil(a)ans = 2 3 5 7 构造一个由A,B两个矩阵中对应位置较大的数组成的矩阵：12345678910111213141516171819202122232425A = 1 2 3 4 5 6&gt;&gt; B = [3 1; 4 6; 2 9]B = 3 1 4 6 2 9&gt;&gt; max(A, B)ans = 3 2 4 6 5 9A = 1 2 3 4 5 6 取出矩阵每列最大的元素：1234&gt;&gt; max(A, [], 1)ans = 5 6 取出矩阵每行最大的元素：123456&gt;&gt; max(A, [], 2)ans = 2 4 6 想要直接获得矩阵中最大的元素，以下两种方式都可以：123456% 方式一：&gt;&gt; max(max(A))ans = 6% 方式二：&gt;&gt; max(A(:))ans = 6 矩阵的上下翻转：1234567891011121314151617&gt;&gt; eye(3)ans =Diagonal Matrix 1 0 0 0 1 0 0 0 1&gt;&gt; flipud(eye(3))ans =Permutation Matrix 0 0 1 0 1 0 1 0 0 矩阵的逆：1234567891011121314151617181920&gt;&gt; A = rand(3, 3)A = 0.68934 0.12881 0.80507 0.49777 0.41907 0.37271 0.32607 0.27877 0.41814&gt;&gt; tmp = pinv(A)tmp = 1.795801 4.294380 -7.285421 -2.180466 0.647802 3.620828 0.053345 -3.780710 5.658801&gt;&gt; tmp * Aans = 1.00000 0.00000 0.00000 0.00000 1.00000 0.00000 -0.00000 -0.00000 1.00000 绘制数据绘制出sin函数图像：123x = [0: 0.01: 0.98];&gt;&gt; y = sin(2*pi*4*x);&gt;&gt; plot(x,y); 绘制出cos函数图像:1y2 = cos(2*pi*4*x); 将两个函数绘制在一起：123&gt;&gt; plot(x,y);&gt;&gt; hold on;&gt;&gt; plot(x,y2,&apos;r&apos;) 添加说明：12345&gt;&gt; xlabel(&quot;time&quot;);&gt;&gt; ylabel(&quot;value&quot;);&gt;&gt; lengend(&quot;sin&quot;, &quot;cos&quot;);error: &apos;lengend&apos; undefined near line 1 column 1&gt;&gt; legend(&quot;sin&quot;, &quot;cos&quot;); 存储图像：1&gt;&gt; print -dpng &quot;myPlot.png&quot; 关掉绘制的图像：1&gt;&gt; close 分别在两个窗口显示两个图像：12&gt;&gt; figure(1); plot(x, y);&gt;&gt; figure(2); plot(x, y2); 改变左边图像的横坐标的刻度：12&gt;&gt; subplot(1,2,1)&gt;&gt; axis([0 0.5 -1 1]) 清除所有绘制的图像：1&gt;&gt; clf 将矩阵可视化：1&gt;&gt; imagesc(magic(15)) 1&gt;&gt; imagesc(A), colorbar, colormap gray 控制语句for循环：1234567&gt;&gt; for i=1:10,&gt; v(i) = i^2;&gt; end;&gt;&gt; vv = 1 4 9 16 25 36 49 64 81 100 while循环：1234567891011&gt;&gt; i = 1;&gt;&gt; while i &lt;= 10,&gt; v(i) = sqrt(v(i));&gt;Display all 1753 possibilities? (y or n)&gt; i = i + 1;&gt; end;&gt;&gt; vv = 1 2 3 4 5 6 7 8 9 10 123456&gt;&gt; lsfeaturesX.dat myPlot.png squareThisNumber.mhello.mat octave-workspacehello.txt priceY.dat&gt;&gt; squareThisNumber(3)ans = 9 如果该定义的函数不在当前目录下，我们就不能使用它：12345&gt;&gt; cd ~&gt;&gt; pwdans = /Users/bobo&gt;&gt; squareThisNumber(3)error: &apos;squareThisNumber&apos; undefined near line 1 column 1 不过我们也可以更改Octave的搜索路径：1&gt;&gt; addpath(&quot;~/Desktop/Machine-Learning&quot;) 更改之后，我们现在虽然在/User/bobo目录下，但是仍然可以使用squareThisNumber函数:1234&gt;&gt; pwdans = /Users/bobo&gt;&gt; squareThisNumber(5)ans = 25 123&gt;&gt; [y1, y2] = squareAndCube(3)y1 = 9y2 = 27 12345678910111213141516171819202122&gt;&gt; X = [1 1; 1 2; 1 3]X = 1 1 1 2 1 3&gt;&gt; y = [1; 2; 3]y = 1 2 3&gt;&gt; theta = [0; 1]theta = 0 1&gt;&gt; costFunctionJ(X, y, theta)ans = 0 如果$\\theta=[0; 0]$12345678&gt;&gt; theta = [0; 0]theta = 0 0&gt;&gt; costFunctionJ(X, y, theta)ans = 2.3333 向量化点击这里–&gt;","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"},{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"},{"name":"Octave","slug":"Octave","permalink":"http://yoursite.com/tags/Octave/"}]},{"title":"Coursera机器学习笔记(三) - 多变量线性回归","slug":"machine_learning_note_03","date":"2018-09-06T07:04:35.958Z","updated":"2018-10-13T17:58:04.807Z","comments":true,"path":"machine_learning_note_03/","link":"","permalink":"http://yoursite.com/machine_learning_note_03/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Linear Regression with Multiple Variables课程Wiki：Linear Regression with Multiple Variables 假设函数 梯度下降假设函数在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征:","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Linear Regression with Multiple Variables课程Wiki：Linear Regression with Multiple Variables 假设函数 梯度下降假设函数在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征: 在实际问题中, 会有很多特征. 例如, 除了房子面积, 还有房子的卧室数量$x_2$，房子的楼层数$x_3$，房子建筑年龄$x_4$，其中$n$表示特征的数量，$m$表示训练样例的数量，$x^{(i)}$表示第$i$个训练样例，$x_j^{(i)}$表示第$i$个训练样例的第$j$个特征。在单变量线性回归中假设函数为:$${h_\\theta(x)=\\theta_0+\\theta_1x}$$类似地, 现在假设函数记作：$${h_\\theta(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+…+\\theta_nx_n}$$可是每次这样写太麻烦了, 为了方便首先定义$x_0=1$（即$x_0^{(i)}=1$），此时$x_0^{(i)}=1$为：$${h_\\theta(x)=\\theta_0x_0+\\theta_1x_1+\\theta_2x_2+…+\\theta_nx_n}$$再令${\\qquad\\qquad\\theta=\\begin{bmatrix}\\theta_0\\ \\theta_1\\ \\theta_2\\.\\.\\.\\ \\theta_n \\end{bmatrix}\\in \\rm I!R^{n+1}\\quad,\\qquad\\qquad}$ ${x=\\begin{bmatrix}x_0\\x_1\\x_2\\.\\.\\.\\x_n \\end{bmatrix}\\in \\rm I!R^{n+1}}$这样就得到了假设函数的向量表示:$${h_\\theta(x)=\\theta_0x_0+\\theta_1x_1+\\theta_2x_2+…+\\theta_nx_n= \\theta^Tx}$$ 梯度下降多变量情况下的梯度下降其实没有区别, 只需要把对应的偏导数项换掉即可。 特征处理特征缩放如果每个特征的范围相差的很大, 梯度下降会很慢. 为了解决这个问题, 我们在梯度下降之前应该对数据做特征归缩放(Feature Scaling)处理，从而将所有的特征的数量级都在一个差不多的范围之内, 以加快梯度下降的速度。假设现在我们有两个特征, 房子的面积和房间的数量. 如下图所示, 他们的范围相差的非常大. 对于这样的数据, 它的代价函数大概如下图左边, 梯度下降要经过很多很多次的迭代才能达到最优点. 如果我们对这两个特征按照右边给出的公式进行特征缩放, 那么此时的代价函数如下图右边所示, 相对于之前, 可以大大减少梯度下降的迭代次数。通常我们需要把特征都缩放到$[-1,1]$（附近）这个范围。 均值归一化还有一个特征处理的方法就是均值归一化(Mean normalization):$${x_i=\\frac{x_i-\\mu_i}{max-min}}$$或者$${x_i=\\frac{x_i-\\mu_i}{\\sigma_i}}$$ 代价函数和学习率我们可以通过画出$\\mathop{min}\\limits_{\\theta}J(\\theta)$与迭代次数数的关系图来观察梯度下降的运行. 如下图所示, 横坐标是迭代次数, 纵坐标是代价函数的值. 如果梯度算法正常运行的话, 代价函数的图像大概的形状如下图所示。还有一种叫自动收敛测试的方法, 即每次迭代之后观察$J(\\theta)$，的值, 如果迭代之后下降的值小于$\\epsilon$（例如$\\epsilon=10^{-3}$），就判定为收敛. 不过准确地选择阈值$\\epsilon$是非常困难的，通常还是使用画图的方法。如果出现了下面的两种情况, 这个时候应该选择更小的$\\alpha$，注意: 1.$\\alpha$足够小, 那么$J(\\theta)$在每次迭代之后都会减小；2.但是如果太小, 梯度下降会进行的非常缓慢。可以使用下面几个值进行尝试 特征选择和多项式回归假设预测房屋价格, 选取房屋的长和宽作为变量, 得到如下的假设函数：$$h(\\theta)=\\theta_0+\\theta_1\\times frontage+\\theta_1\\times depth$$当然, 我们觉得真正决定房屋价格应该是与房屋的面积有关. 这时候我们也可以重新选择我们的特征$x=frontage\\times depth$，此时的假设函数为：$$h(\\theta)=\\theta_0+\\theta_1x$$通过这种特征的选择, 我们可能得到一个更好的模型和这个密切相关的一个概念就是多项式回归(Polynomial Regression). 假设有下图所示的关于房屋价格的数据集, 我们有多种模型去拟合(下图右所示). 第一个模型是一个二次函数, 但是二次函数是一个抛物线, 这里不符合(因为房价不会随着房子面积的增加二减小)；所以我们选择三次函数的模型, 想要使用该模型去拟合. 那么我们该如何将这个模型运用在我们的数据上呢？我们可以将房屋的面积作为第一个特征, 面积的平方作为第二个特征, 面积的立方作为第三个特征, 如下图左下角所示. (这里需要注意的是, $x_0,x_1,x_2$的范围差别会非常大, 所以一定要进行特征缩放处理）除了三次函数模型, 这里也可以选择平方根函数模型, 如下图所示 正规方程正规方程之前我们一直是用的梯度下降求解最优值. 它的缺点就是需要进行很多次迭代才能得到全局最优解. 有没有更好的方法呢? 我们先来看一个最简单的例子, 假设现在的代价函数为$J(\\theta)=a\\theta^2+b\\theta+c$，$\\theta$是一个实数. 怎样得到最优解? 很简单, 只要令它的导数为0就可以了。事实上, 代价函数不会像例子那样简单, $\\theta$也不是一个实数，而是一个$n+1$维的向量，这样, 我们分别对每个$\\theta$求偏导，再令偏导等于0, 可以计算出左右的$\\theta$，了. 但看上去还是很繁琐, 所以下面我们介绍一种向量化的求解方法。首先, 在数据集前加上一列$x_0$，值都为1；然后将所有的变量都放入矩阵$X$中(包括加上的$x_0$)；再将输出值放入向量$y$中。最后通过公式$\\theta=(X^TX)^{-1}X^Ty$，就可以算出$\\theta$的值。下图是一个更通用的表达方式：在Octave中, 可用如下命令计算:1pinv(x&apos;*x)*x&apos;*y 这个公式叫做正规方程, 使用这种方法还有一个好处就是不需要进行特征缩放处理。 梯度下降与正规方程的比较下图是梯度下降(Gradient Descent)和正规方程(Normal Equation)两种方法优缺点的比较： 正规方程不可逆的情况使用正规方程还有一个问题就是$X^TX$可能存在不可逆的情况。这个时候, 可能是因为我们使用了冗余的特征, 还有一个原因是我们使用了太多的特征(特征的数量超过了样本的数量)。对于这种情况我们可以删掉一些特征或者使用正则化(正则化在后面的课中讲)。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"},{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"}]},{"title":"《极恶非道》观后感","slug":"jiefeidao_comment","date":"2018-09-05T14:18:06.603Z","updated":"2018-09-05T14:18:06.603Z","comments":true,"path":"jiefeidao_comment/","link":"","permalink":"http://yoursite.com/jiefeidao_comment/","excerpt":"无关乎生存，仅在乎利益。这是电影交代的黑帮从上而下的恶，这种恶充斥了整部电影，不仅黑帮，也有警察。 北野武是以拍摄黑帮片出道，早期的《奏鸣曲》是一部故事完全发生黑帮内部的电影，但北野武没有把电影拍成类型化的模式，而是嚼碎了各种类型化的元素，为之注入了他个人独特的对于荒诞生命的严峻思考。2000年赴美拍摄的《大佬》倒是比较类型化，影片不断展示帮派战斗的过程，还充满了东西方文化的差异比较，生死相托的日式侠义精神在影片中被反复讴歌。","text":"无关乎生存，仅在乎利益。这是电影交代的黑帮从上而下的恶，这种恶充斥了整部电影，不仅黑帮，也有警察。 北野武是以拍摄黑帮片出道，早期的《奏鸣曲》是一部故事完全发生黑帮内部的电影，但北野武没有把电影拍成类型化的模式，而是嚼碎了各种类型化的元素，为之注入了他个人独特的对于荒诞生命的严峻思考。2000年赴美拍摄的《大佬》倒是比较类型化，影片不断展示帮派战斗的过程，还充满了东西方文化的差异比较，生死相托的日式侠义精神在影片中被反复讴歌。《极恶非道》是北野武十年后回归暴力黑社会的作品。影片的叙事法则便是你来我往的夺权战斗。叙事出发点始于关内会长（北村总一朗 扮）要抢夺村濑（石桥莲司 扮）组的地盘，用的策略是并不高明的挑拨离间，让曾经与村濑为狱友的池元（国村隼 扮）与之大战。池元手下的大友（北野武 扮）组与村濑组的木村（中野英雄 扮）也随之展开斗争。这是一部众生相电影，与之相关的重要角色还有大友组的石原（加濑亮 扮）、水野（椎名桔平 扮），会长手下的加藤（三浦友和 扮），负责暴力团事物的警察片冈。影片的日文片名直译是《全员恶人》，这里面确实没有一个道德方面的善良之辈，没有英雄，只有恶人。尤其是几个首领，关内会长、池元、村濑，没有任何道义和领袖魅力可言，有的只是利欲熏心。过往日本黑帮组织的一些情义亦是荡然无存。池元与村濑本来是狱友，在《无仁义之战》第一集中，狱友曾经是被表现为敢用性命相托的赤胆忠诚之关系，在本片中却是一文不值，面对质问，池元甚至说，“拜把只是个仪式”。木村连切手指都不敢。而当大友当真用切手指的方法道歉时，却被会长讥讽这过时了，“老套的切手指没有用”。在此特别值得一提的是北野扮演的大友这个角色，正是这个角色的存在为这部黑帮片注入了一些别样的独属于北野武式思考的活力。 大友在影片虽亦是热衷暴力的恶人，但在道义上却是偏向正面。他当真视池元为干爹，为其卖命，但随后看透了这套把戏之后，意识到这是一场你死我活的战斗。黑帮中人，本来已经看透生死，当意识到道之不存后，大友便将这场战斗看成了无关道义的死亡游戏。死亡到来的时刻便是当下澄明的解脱时刻，这是北野武式洒脱豁达当下即是的生命哲学。正是这个视点又为这部类型化程度很高的黑帮电影，注入了一种抽离的客观化的视点。也正是在北野武独特生命哲学的关照之下，与死亡密切相关的暴力，被北野武表达的如此极致。北野武多年来的采访中曾多次表达了个人对暴力的看法，他讨厌美感的暴力，他认为暴力的本质就是伤痛，“暴力就是暴力，我希望用暴力的镜头刺痛观众，让他们知道暴力有多么糟糕，所以我不会顾忌该用什么样的方式，用多野蛮的力度。也许你们看电影的时候，已经觉得承受不了了，但其实这是我故意制造出来的，我希望让观众感到剧烈的疼痛和恐惧，这种感觉就是暴力的本质。我最讨厌那种把暴力拍得很美的电影，还冠以暴力美学的美称，那样的电影才是教坏小孩子的罪魁祸首”。吴宇森式的自我崇高化的浪漫暴力，或者塔伦蒂诺式卡通恶趣味暴力，在北野武的电影中是看不到的。瞬间爆发的，极致的，带来无比伤痛的暴力才是真正的北野暴力。在《极恶非道》系列中，北野勾画出的暴力类型亦是极端残酷：电钻凿牙齿、筷子猛插耳朵、猛击舌头导致卡舌而死、棒球连续性地击砸面门。最汹涌澎湃的无情暴力莫过于与大友并肩作战到最后的水野：头颅被绳子套住后飞车拉断而死。 《极恶非道》系列第二集的主题与叙事模式与第一集类似，只是权斗的始作俑者变成了警察片冈。警方这套挑拨离间以暴易暴的制敌模式也是其来有自。1987年，一和会与山口组发生了激烈的暴力抗争。当时，一合会打算在大阪地区刺杀新上任的山口组组长竹中正久，他们用了二十多部无线电对讲机。关西电信局发现情况后报警，但警方不予理睬，为的就是帮助一合会行刺，以暴易暴。不过片冈在影片中并非正义人士，而是猥琐的敲诈犯，当大友看破这死局后，二话不说一枪击毙片冈。影片的高潮来得猝不及防，但却酣畅淋漓，激越又超然。 这是一部非常纯正的yakuza电影，而电影中表现的暴力和深作欣二的热血翻滚不同，北野武的暴力凝固至冰点，让人看完脊背发凉。 最激烈的暴力与死亡冲动同样可以是最深邃的生命顿悟。","categories":[{"name":"影评","slug":"影评","permalink":"http://yoursite.com/categories/影评/"}],"tags":[{"name":"北野武","slug":"北野武","permalink":"http://yoursite.com/tags/北野武/"},{"name":"yakuza","slug":"yakuza","permalink":"http://yoursite.com/tags/yakuza/"}]},{"title":"Coursera机器学习笔记(二) - 单变量线性回归(补充 - 梯度下降算法)","slug":"machine_learning_note_02_addition","date":"2018-09-05T13:51:57.176Z","updated":"2018-10-13T03:15:41.138Z","comments":true,"path":"machine_learning_note_02_addition/","link":"","permalink":"http://yoursite.com/machine_learning_note_02_addition/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 梯度下降梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\\theta_0$、$\\theta_1$。它的思想是, 首先随机选择两个$\\theta_0$、$\\theta_1$，不断地改变它们的值使得$J(\\theta_0,\\theta_1)$变小，最终找到$J(\\theta_0,\\theta_1)$的最小值。","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 梯度下降梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\\theta_0$、$\\theta_1$。它的思想是, 首先随机选择两个$\\theta_0$、$\\theta_1$，不断地改变它们的值使得$J(\\theta_0,\\theta_1)$变小，最终找到$J(\\theta_0,\\theta_1)$的最小值。 可以把梯度下降的过程想象成下山坡, 如果想要尽可能快的下坡, 应该每次都往坡度最大的方向下山。梯度下降算法得到的结果会受到初始状态的影响, 即当从不同的点开始时, 可能到达不同的局部极小值, 如下图:下面具体看一下算法的过程, 如下图所示, 其中$:=$表示赋值，$\\alpha$表示学习率用来控制下降的幅度，$\\frac{\\partial}{\\partial\\theta_j}J(\\theta_0, \\theta_1)$表示梯度。这里一定要注意的是，算法每次是同时(simultaneously)改变$\\theta_0$和$\\theta_1$的值，如下图所示 梯度和学习率我们先来看看梯度下降算法的梯度是如何帮助我们找到最优解的. 为了研究问题的方便我们还是同样地令$\\theta_0=0$，假设一开始选取的$\\theta_1$在最低点右侧，此时的梯度(斜率)是一个正数。根据上面的算法更新$\\theta_1$的时候，它的值会减小, 即靠近最低点。类似地假设一开始选取的$\\theta_1$在最低点的左侧，此时的梯度是一个负数，根据上面的算法更新$\\theta_1$的时候，它的值会增大，也会靠近最低点。如果一开始选取的$\\theta_1$恰好在最适位置，那么更新$\\theta_1$时，它的值不会发生变化。 学习率$\\alpha$会影响梯度下降的幅度。如果$\\alpha$太小，$\\theta$的值每次会变化的很小，那么梯度下降就会非常慢；相反地，如果$\\alpha$太大，$\\theta$的值每次会变化的很大，有可能直接越过最低点，可能导致永远没法到达最低点。由于随着越来越接近最低点, 相应的梯度(绝对值)也会逐渐减小，所以每次下降程度就会越来越小, 我们并不需要减小$\\alpha$的值来减小下降程度。 计算梯度根据定义, 梯度也就是代价函数对每个$\\theta$求偏导：我们将$h_\\theta(x^{(i)})=\\theta_0+\\theta_1x^{(i)}$带入到$J(\\theta_0,\\theta_1)$中，并且分别对$\\theta_0$，$\\theta_1$求导得：由此得到了完整的梯度下降算法:前面说了梯度下降算法得到的结果会受初始状态的影响, 即初始状态不同, 结果可能是不同的局部最低点。事实上，用于线性回归的代价函数总是一个凸函数(Convex Function)。这样的函数没有局部最优解，只有一个全局最优解。所以我们在使用梯度下降的时候，总会得到一个全局最优解。下面我们来看一下梯度下降的运行过程：迭代多次后，我们得到了最优解。现在我们可以用最优解对应的假设函数来对房价进行预测了。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"},{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"}]},{"title":"Coursera机器学习笔记(二) - 单变量线性回归","slug":"machine_learning_note_02","date":"2018-09-04T14:27:55.458Z","updated":"2018-10-12T08:52:53.708Z","comments":true,"path":"machine_learning_note_02/","link":"","permalink":"http://yoursite.com/machine_learning_note_02/","excerpt":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Linear Regression with One Variable课程Wiki：Linear Regression with One Variable 基本概念训练集由训练样例(training example)组成的集合就是训练集(training set)，如下图所示, 其中$(x, y)$是一个训练样例, $(x^{(i)}, y^{(i)})$第i个训练样例。","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} }); 课程地址：Linear Regression with One Variable课程Wiki：Linear Regression with One Variable 基本概念训练集由训练样例(training example)组成的集合就是训练集(training set)，如下图所示, 其中$(x, y)$是一个训练样例, $(x^{(i)}, y^{(i)})$第i个训练样例。 假设函数使用某种学习算法对训练集的数据进行训练, 我们可以得到假设函数(Hypothesis Function), 如下图所示. 在房价的例子中，假设函数就是一个房价关于房子面积的函数。有了这个假设函数之后, 给定一个房子的面积我们就可以预测它的价格了。我们使用如下的形式表示假设函数, 为了方便，$h_\\theta(x)$也可以记作$h(x)$$${h_\\theta(x)=\\theta_0+\\theta_1x}$$以上这个模型就叫做单变量的线性回归(Linear Regression with One Variable). (Linear regression with one variable = Univariate linear regression，univariate是one variable的装逼写法。) 代价函数什么是代价函数只要我们知道了假设函数, 我们就可以进行预测了. 关键是, 假设函数中有两个未知的量$\\theta_0, \\theta_1$，当选择不同的$\\theta_0$和$\\theta_1$时，我们模型的效果肯定是不一样的。如下图所示, 列举了三种不同的$\\theta_0$和$\\theta_1$下的假设函数。现在的问题就是该如何选择这两个参数了。我们的想法是选择某个$\\theta_0$和$\\theta_1$，使得对于训练样例$(x,y)$，$h_\\theta(x)$最接近$y$。越是接近, 代表这个假设函数越是准确, 这里我们选择均方误差来作为衡量标准, 即我们想要每个样例的估计值与真实值之间差的平方的均值最小。用公式表达为:$${\\mathop{minimize}\\limits_{\\theta_0,\\theta_1} \\frac{1}{2m}\\sum_{i=0}^m\\left(h_\\theta(x^{(i)})-y^{(i)}\\right)^2}$$（其中$1/2$是为了后面方便计算）我们记$${J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum_{i=0}^m\\left(h_\\theta(x^{(i)})-y^{(i)}\\right)^2}$$这样就得到了我们的代价函数(cost function), 也就是我们的优化目标, 我们想要代价函数最小:$$\\mathop{minimize}\\limits_{\\theta_0,\\theta_1}J(\\theta_0,\\theta_1)$$ 代价函数和假设函数现在为了更方便地探究$h_\\theta(x)$和$J(\\theta_0,\\theta_1)$的关系，先令$\\theta_0=0$，得到了简化后的假设函数，有假设函数的定义可知此时的假设函数是经过原点的直线. 相应地也也得到简化的代价函数。如图所示:简化之后，我们令$\\theta_1=1$，就得到$h_\\theta(x)=x$，如下图左所示。图中三个红叉表示训练样例，通过代价函数的定义我们计算得出$J(1)=0$，对应下图右中的$(0,1)$坐标重复上面的步骤，再令$\\theta_1=0.5$，得到$h_\\theta(x)$如下图左所示。通过计算得出$J(0.5)=0.58$，对应下图右中的$(0.5,0.58)$对于不同的$\\theta_1$，对应着不同的假设函数$h_\\theta(x)$，于是就有了不同的$J(\\theta_1)$。将这些点连接起来就可以得到$J(\\theta_1)$关于$\\theta_1$的函数图像，如下图所示：我们的目标就是找到一个$\\theta$使得$J(\\theta)$最小，通过上面的描点作图的方式, 我们可以从图中看出, 当$\\theta=1$的时候，$J(\\theta)$取到最小值。 代价函数与假设函数II在上一节中，我们令$\\theta_0=0$，并且通过设置不同的$\\theta_1$来描点作图得到$J(\\theta_1)$的曲线。这一节我们不再令$\\theta_0=0$，而是同时设置$\\theta_0$和$\\theta_1$的值，然后再绘出$J(\\theta_0, \\theta_1)$的图形。因为此时有两个变量，很容易想到$J(\\theta_0, \\theta_1)$应该是一个曲面, 如下图所示:这个图是教授用matlab绘制的，由于3D图形不太方便我们研究，我们就使用二维的等高线(上图右上角教授写的contour plots/figures)，这样看上去比较清楚一些。如下图右，越靠近中心表示$J(\\theta_0, \\theta_1)$的值越小(对应3D图中越靠近最低点的位置)。下图左表示当$\\theta_0=800$，$\\theta_1=0.15$的时候对应的$h_\\theta(x)$，通过$\\theta_0$和$\\theta_1$的值可以找到下图右中$J(\\theta_0, \\theta_1)$的值。类似地：我们不断尝试直到找到一个最佳的$h_\\theta(x)$。是否有特定的算法能帮助我们找到最佳的$h_\\theta(x)$呢？下面我们就要介绍这个算法-梯度下降算法。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"},{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"}]},{"title":"Coursera机器学习笔记(一) - 监督学习vs无监督学习","slug":"machine_learning_note_01","date":"2018-09-04T14:03:23.953Z","updated":"2018-10-12T05:43:02.609Z","comments":true,"path":"machine_learning_note_01/","link":"","permalink":"http://yoursite.com/machine_learning_note_01/","excerpt":"课程地址：Supervised Learning &amp; Unsupervised Learning课程Wiki：Introduction 监督学习什么是监督学习? 我们来看看维基百科中给出的定义: 监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类） 从数据的角度来讲, 监督学习和无监督学习的区别就在于监督学习的数据不仅仅有特征组成, 即每一个数据样本都包含一个准确的输出值. 在房价预测的问题中, 数据由特征+房价组成。","text":"课程地址：Supervised Learning &amp; Unsupervised Learning课程Wiki：Introduction 监督学习什么是监督学习? 我们来看看维基百科中给出的定义: 监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类） 从数据的角度来讲, 监督学习和无监督学习的区别就在于监督学习的数据不仅仅有特征组成, 即每一个数据样本都包含一个准确的输出值. 在房价预测的问题中, 数据由特征+房价组成。 监督学习的分类在监督学习中, 我们的预测结果可以是连续值, 也可以是离散值。我们根据这样的属性将监督学习分为回归问题和分类问题。下面我们分别举一个例子来看看, 学完这两个例子之后, 我们就会对监督学习, 回归以及分类有比较清晰地认识了。 监督学习举例回归问题我们现在有这么一个问题, 我们想通过给定的一个房子的面积来预测这个房子在市场中的价格。这里的房子的面积就是特征, 房子的价格就是一个输出值。为了解决这个问题, 我们获取了大量的房地产数据, 每一条数据都包含房子的面积及其对应价格. 第一, 我们的数据不仅包含房屋的面积, 还包含其对应的价格, 而我们的目标就是通过面积预测房价。所以这应该是一个监督学习; 其次, 我们的输出数据房价可以看做是连续的值, 所以这个问题是一个回归问题。至于如何通过数据得到可以使用的模型, 后面的几节课再做讨论。 分类问题再来看一个分类问题, 从名字上来讲, 分类问题还是比较好理解的, 我们的目标应该是要对数据进行分类。现在我们的数据是有关乳腺癌的医学数据, 它包含了肿瘤的大小以及该肿瘤是良性的还是恶性的。我们的目标是给定一个肿瘤的大小来预测它是良性还是恶性. 我们可以用0代表良性，1代表恶性。这就是一个分类问题, 因为我们要预测的是一个离散值。当然, 在这个例子中, 我们的离散值可以去’良性’或者’恶性’. 在其他分类问题中, 离散值可能会大于两个。例如在该例子中可以有{0,1,2,3}四种输出，分别对应{良性, 第一类肿瘤, 第二类肿瘤, 第三类肿瘤}。在这个例子中特征只有一个即瘤的大小。 对于大多数机器学习的问题, 特征往往有多个(上面的房价问题也是, 实际中特征不止是房子的面积)..例如下图， 有“年龄”和“肿瘤大小”两个特征。(还可以有其他许多特征，如下图右侧所示) 无监督学习在监督学习中我们也提到了它与无监督学习的区别。在无监督学习中, 我们的数据并没有给出特定的标签, 例如上面例子中的房价或者是良性还是恶性。我们目标也从预测某个值或者某个分类便成了寻找数据集中特殊的或者对我们来说有价值结构。我们也可以从图中看到, 大概可以将数据及分成两个簇。将数据集分成不同簇的无监督学习算法也被称为聚类算法。 无监督学习举例新闻分类第一个例子举的是Google News的例子。Google News搜集网上的新闻，并且根据新闻的主题将新闻分成许多簇, 然后将在同一个簇的新闻放在一起。如图中红圈部分都是关于BP Oil Well各种新闻的链接，当打开各个新闻链接的时候，展现的都是关于BP Oil Well的新闻。 根据给定基因将人群分类如图是DNA数据，对于一组不同的人我们测量他们DNA中对于一个特定基因的表达程度。然后根据测量结果可以用聚类算法将他们分成不同的类型。 鸡尾酒排队效应详见课程: Unsupervised Learning 其他这里又举了其他几个例子，有组织计算机集群，社交网络分析，市场划分，天文数据分析等。具体可以看一下视频：Unsupervised Learning","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"},{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"}]},{"title":"机器学习资料整理","slug":"machine_learning_materials","date":"2018-09-03T10:38:41.948Z","updated":"2018-09-03T11:26:46.850Z","comments":true,"path":"machine_learning_materials/","link":"","permalink":"http://yoursite.com/machine_learning_materials/","excerpt":"微积分&emsp;&emsp;Single Variable Calculus - MIT 线性代数&emsp;&emsp;Linear Algebra - MIT","text":"微积分&emsp;&emsp;Single Variable Calculus - MIT 线性代数&emsp;&emsp;Linear Algebra - MIT 概率论与数理统计&emsp;&emsp;(暂无) 凸优化&emsp;&emsp;(暂无) Python&emsp;&emsp;廖雪峰Python教程&emsp;&emsp;Learn python in Y minutes 机器学习&emsp;&emsp;Coursera机器学习 - Andrew Ng&emsp;&emsp;CS229 - Andrew Ng&emsp;&emsp;《统计学习方法》- 李航&emsp;&emsp;《机器学习》 - 周志华&emsp;&emsp;Udacity Machine Learning Engineer Nanodegree 深度学习&emsp;&emsp;Coursera Deep Learning Sepecialization - deeplearning.ai 自然语言系统&emsp;&emsp;(暂无) 推荐系统&emsp;&emsp;推荐系统实践 - 项亮 竞赛&emsp;&emsp;Kaggle","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"machinelearning","slug":"machinelearning","permalink":"http://yoursite.com/tags/machinelearning/"},{"name":"deeplearning","slug":"deeplearning","permalink":"http://yoursite.com/tags/deeplearning/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"}]},{"title":"吴恩达机器学习笔记-目录","slug":"machine_learning_note","date":"2018-09-03T09:47:33.890Z","updated":"2018-09-24T06:26:51.468Z","comments":true,"path":"machine_learning_note/","link":"","permalink":"http://yoursite.com/machine_learning_note/","excerpt":"","text":"持续更新中…… Coursera机器学习笔记(一) - 监督学习vs无监督学习Coursera机器学习笔记(二) - 单变量线性回归Coursera机器学习笔记(三) - 多变量线性回归Coursera机器学习笔记(四) - Octave教程Coursera机器学习笔记(五) - Logistic RegressionCoursera机器学习笔记(六) - 正则化Coursera机器学习笔记(七) - 神经网络(上)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/tags/Machine-Learning/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"},{"name":"Note","slug":"Note","permalink":"http://yoursite.com/tags/Note/"}]}]}